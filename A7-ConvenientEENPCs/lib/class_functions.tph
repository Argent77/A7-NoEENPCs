INCLUDE ~%MOD_FOLDER%/lib/a7_cre_functions.tph~
INCLUDE ~%MOD_FOLDER%/lib/kit_functions.tph~

// Function Overview:
// a7#change_cre_class                  Patch function: Main function that changes the class/kit combination of the current CRE according to the specified parameters.
// a7#change_cre_class_levels           Patch function: Used internally to set class levels and hit points.
// a7#change_cre_thieving_skills        Patch function: Used internally to assign thieving skills based on a map of skill weights.
// a7#change_cre_proficiencies          Patch function: Used internally to assign weapon proficiencies based on the given proficiency arrays.
// a7#change_cre_spells                 Patch function: Used internally to assign known and memorized spells based on the given parameters.
// a7#reset_class                       Patch function: Resets the attributes of the current CRE (required for assigning new class and/or levels).
// a7#assign_class                      Patch function: Assigns a new class with optional kit to the current CRE.
// a7#assign_level                      Patch function: Sets the level(s) of the current CRE to the specified value.
// a7#assign_thieving_skills            Patch function: Distributes points to thieving skills in the current CRE according to the specified parameters.
// a7#get_profs_from_cre                Patch function: Builds an indexed array with proficiency values from the proficiency effects defined in the current CRE resource.
// a7#assign_proficiencies              Patch function: Removes current proficiency definitions and applies the specified number of proficiencies to the current CRE.
// a7#validate_reset                    Patch function: Returns whether the current CRE has been successfully reset.
// a7#get_known_spells_from_cre         Patch function: Builds an indexed array with spell resrefs from the known spells section of the current CRE resource.
// a7#get_memorized_spells_from_cre     Patch function: Builds an indexed array with spell resrefs from the memorized spells section of the current CRE resource.
// a7#add_spells                        Patch function: Assigns a set of known and/or memorized spells to the current CRE.
// a7#validate_equipped_items           Patch function: Performs a check on equipped items whether they are usable by the current CRE resource.
// a7#is_item_usable                    Patch function: Returns whether the specified item is usable by the current CRE resource.
// a7#calculate_hitpoints               Dimorphic function: Returns the hit points value based on the specified class and levels.
// a7#calculate_ac                      Dimorphic function: Returns the effective AC and specific AC modifiers based on the specified parameters.
// a7#calculate_thac0                   Dimorphic function: Returns the THAC0 value based on the specified parameters.
// a7#calculate_lore                    Dimorphic function: Returns the Lore value based on the specified parameters.
// a7#calculate_saving_throws           Dimorphic function: Returns saving throw values based on the specified class and levels.
// a7#calculate_thieving_skills         Dimorphic function: Returns thieving skill values based on the specified parameters.
// a7#calculate_proficiencies           Dimorphic function: Returns number of proficiency points and an array of proficiencies and styles.
// a7#calculate_spell_slots             Dimorphic function: Returns number of available spell slots as well as number of known spells for the specified class.
// a7#get_class_category                Dimorphic function: Returns the class category of the specified class. This function works only on single classes.
// a7#evaluate_original_class           Dimorphic function: Checks if an original class is defined and addresses a class aspect of the dual-class.
// a7#get_class_levels                  Dimorphic function: Returns the individual class levels based on the specified parameters.
// a7#get_base_classes                  Dimorphic function: Returns the individual class aspects of the given class.
// a7#get_kit_info                      Dimorphic function: Returns additional information about the specified kit.
// a7#get_spell_info                    Dimorphic function: Returns details about the specified spell resource.
// a7#is_spell_usable                   Dimorphic function: Returns whether the specified CRE and SPL parameters are compatible.
// a7#get_mage_kit_school               Dimorphic function: Returns the magic school identifier of the specified specialist mage kit id.
// a7#get_spell_picks                   Dimorphic function: Returns an indexed array with a random choice of mage spells that are compatible with the given parameters.
// a7#pregen_spells_array               Dimorphic function: Returns an indexed array with all known priest and/or druid spells that are compatible with the given parameters.
// a7#get_clab                          Dimorphic function: Returns the CLAB tables associated with the specified class/kit combination.
// a7#is_innate_defined                 Dimorphic function: Determines whether an innate spell is granted by the specified class or kit.
// a7#get_animation_id                  Dimorphic function: Returns the creature animation value that matches the specified parameters.
// a7#get_haterace                      Dimorphic function: Returns a map of allowed racial enemies for the ranger class.
// a7#convert_kit_label                 Dimorphic function: Returns kit id or kit label based on the given input.


// Definition for "no kit"
OUTER_SET TRUECLASS = 0x4000

// Mask for specialist mage bits
OUTER_SET SPECIALIST_MAGE_MASK = BIT6 | BIT7 | BIT8 | BIT9 | BIT10 | BIT11 | BIT12 | BIT13 | BIT31

/**
 * This patch function changes the class/kit combination of the current CRE according to the specified parameters.
 * It updates all relevant creature attributes, distributes thieving points and assigns user-defined spells if available.
 *
 * INT_VAR class                    Numeric identifier of the new class (CLASS.IDS). Specify -1 to keep the current class.
 *                                  (Default: -1)
 * INT_VAR kit                      Numeric identifier of the new kit (KIT.IDS). Specify -1 to keep the current kit.
 *                                  Specify 0 for a kit-less class change. (Default: -1)
 * INT_VAR original_class           (Dual-class only) Numeric identifier of the original class (CLASS.IDS). Specify if
 *                                  the class change doesn't involve dual-classing. (Default: 0)
 * INT_VAR original_level           (Dual-class only) Level of the original class. Value must be 2 or greater for
 *                                  successful dual-classing. This value is only considered if "original_class" is set.
 *                                  (Default: 0)
 * INT_VAR xp                       New amount of experience points. Specify -1 to keep the current XP value of the
 *                                  creature. (Default: -1)
 * INT_VAR hp_mode                  Controls how hit points are calculated. Supported modes: 0=use dice values as defined
 *                                  by the HP tables, 1=calculated value is slightly below max. HP, 2=use max. HP) (Default: 1)
 * INT_VAR remove_unusable          Specifies whether items that are unusable by the new class/kit combination should be
 *                                  unequipped and placed into the inventory. Undroppable items are not affected.
 *                                  (Default: 1)
 * INT_VAR keep_innates             Specifies whether innate abilities without references to CLAB tables should be retained
 *                                  by a class/kit change. (Default: 1)
 * STR_VAR profs_warrior            Name of the 0-based indexed array with proficiency labels or identifiers for warrior
 *                                  classes. Entries are cumulative. It should contain enough entries to spend on the
 *                                  class/level of the character. (Default: "profs_warrior")
 * STR_VAR profs_rogue              Name of the 0-based indexed array with proficiency labels or identifiers for rogue
 *                                  classes. Entries are cumulative. It should contain enough entries to spend on the
 *                                  class/level of the character. (Default: "profs_rogue")
 * STR_VAR profs_priest             Name of the 0-based indexed array with proficiency labels or identifiers for priest
 *                                  classes. Entries are cumulative. It should contain enough entries to spend on the
 *                                  class/level of the character. (Default: "profs_priest")
 * STR_VAR profs_wizard             Name of the 0-based indexed array with proficiency labels or identifiers for wizard
 *                                  classes. Entries are cumulative. It should contain enough entries to spend on the
 *                                  class/level of the character. (Default: "profs_wizard")
 * STR_VAR thieving_weights         Name of the associative array with individual weight definitions for thieving skills,
 *                                  as "<skill_name>" => <weight> entries. Weight values are relative to each other.
 *                                  Supported thieving skill names: "pick_pockets", "open_locks", "find_traps",
 *                                  "move_silently", "hide_in_shadows", "detect_illusion", "set_traps".
 *                                  (Default: "thieving_weights")
 * STR_VAR known_spells_shaman      Name of a 0-based indexed array with known spells for the Shaman class. Array
 *                                  should contain definitions for all spell levels. (Default: "known_spells_shaman")
 * STR_VAR memorized_spells_cleric  Name of a 0-based indexed array with memorizable spells for clerics and paladins.
 *                                  Array should contain definitions for all spell levels. Duplicate spell definitions
 *                                  are cumulative. (Default: "memorized_spells_cleric")
 * STR_VAR memorized_spells_druid   Name of a 0-based indexed array with memorizable spells for druids and rangers.
 *                                  Array should contain definitions for all spell levels. Duplicate spell definitions
 *                                  are cumulative. (Default: "memorized_spells_druid")
 * STR_VAR known_spells_wizard      Name of a 0-based indexed array with known spells for mages, bards and sorcerers.
 *                                  Array should contain definitions for all spell levels. (Default: "known_spells_wizard")
 * STR_VAR memorized_spells_wizard  Name of a 0-based indexed array with memorizable spells for mages and bards. Array
 *                                  should contain definitions for all spell levels. Duplicate spell definitions are
 *                                  cumulative. (Default: "memorized_spells_wizard")
 * STR_VAR known_spells_innate      Name of a 0-based indexed array with known innate spells. Array should contain
 *                                  definitions for all spell levels. (Default: "known_spells_innate")
 * STR_VAR memorized_spells_innate  Name of a 0-based indexed array with memorizable innate spells. Duplicate spell
 *                                  definitions are cumulative. (Default: "memorized_spells_innate")
 * RET success                      Returns 1 if the class change operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#change_cre_class
INT_VAR
  class                   = "-1"
  kit                     = "-1"
  original_class          = 0
  original_level          = 0
  xp                      = "-1"
  hp_mode                 = 1
  remove_unusable         = 1
  keep_innates            = 1
STR_VAR
  profs_warrior           = ~profs_warrior~
  profs_rogue             = ~profs_rogue~
  profs_priest            = ~profs_priest~
  profs_wizard            = ~profs_wizard~
  thieving_weights        = ~thieving_weights~
  known_spells_shaman     = ~known_spells_shaman~
  memorized_spells_cleric = ~memorized_spells_cleric~
  memorized_spells_druid  = ~memorized_spells_druid~
  known_spells_wizard     = ~known_spells_wizard~
  memorized_spells_wizard = ~memorized_spells_wizard~
  known_spells_innate     = ~known_spells_innate~
  memorized_spells_innate = ~memorized_spells_innate~
RET
  success
BEGIN
  // reset levels only: try to preserve full known wizard spells list
  SET add_verbatim = (class == "-1" && kit == "-1" && ~%known_spells_wizard%~ STR_EQ ~~)

  PATCH_IF (class == "-1") BEGIN
    READ_BYTE 0x273 class
  END

  PATCH_IF (kit == "-1") BEGIN
    SET kit = ((SHORT_AT 0x244) << 16) | (SHORT_AT 0x246)
  END

  PATCH_IF (xp == "-1") BEGIN
    SET xp = LONG_AT 0x18
  END

  // parameter checks
  LPF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
  SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : (class1 > 0) ? 1 : 0
  SET success = (num_classes > 0)
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Invalid class: %class%~
  END

  PATCH_IF (success) BEGIN
    PATCH_FOR_EACH param IN ~profs_warrior~ ~profs_rogue~ ~profs_priest~ ~profs_wizard~ BEGIN
      PATCH_IF (success) BEGIN
        // building weapon proficiency array from current CRE proficiency if profs array isn't provided
        PATCH_IF (EVAL ~%%param%%~ STR_EQ ~~) BEGIN
          LPF a7#get_profs_from_cre RET profs_array RET_ARRAY profs_array END

          // proficiency definitions must exist
          PATCH_IF (profs_array > 0) BEGIN
            SPRINT EVAL ~%param%~ ~profs_array~
          END
        END

        SET success = NOT ~%%param%%~ STR_EQ ~~
        PATCH_IF (success) BEGIN
          // ensure that weapon proficiencies are defined as numeric values
          FOR (i = 0; VARIABLE_IS_SET $EVAL ~%param%~(~%i%~); ++i) BEGIN
            SPRINT prof $EVAL ~%param%~(~%i%~)
            PATCH_IF (NOT IS_AN_INT ~prof~) BEGIN
              SET prof_id = IDS_OF_SYMBOL(~stats~ ~%prof%~)
              SET $EVAL ~%param%~(~%i%~) = prof_id
              PATCH_IF (prof_id < 0) BEGIN
                PATCH_WARN ~WARNING: Invalid weapon proficiency at $%param%(%i%): %prof%~
              END
            END
          END
        END ELSE BEGIN
          PATCH_WARN ~WARNING: "%param%" array name not specified~
        END
      END
    END
  END

  PATCH_IF (success) BEGIN
    // checking dualclass parameters
    PATCH_IF (original_class != 0) BEGIN
      LPF a7#evaluate_original_class INT_VAR class original_class RET original_class END
      PATCH_IF (original_class == 0 || original_level < 2) BEGIN
        // not a critical issue
        PATCH_WARN ~WARNING: Invalid dual-class parameters specified.~
      END
    END

    // building thieving weights map from current CRE if definitions aren't provided
    PATCH_IF (~%thieving_weights%~ STR_EQ ~~) BEGIN
      SET $a7#thieving_weights(~pick_pockets~) = BYTE_AT 0x6a
      SET $a7#thieving_weights(~open_locks~) = BYTE_AT 0x67
      SET $a7#thieving_weights(~find_traps~) = BYTE_AT 0x69
      SET $a7#thieving_weights(~move_silently~) = BYTE_AT 0x68
      SET $a7#thieving_weights(~hide_in_shadows~) = BYTE_AT 0x45
      SET $a7#thieving_weights(~detect_illusion~) = BYTE_AT 0x64
      SET $a7#thieving_weights(~set_traps~) = BYTE_AT 0x65
      SPRINT thieving_weights ~a7#thieving_weights~
    END

    // building known/memorized spell arrays from current CRE spell list if definitions aren't provided
    PATCH_IF (~%known_spells_shaman%~ STR_EQ ~~) BEGIN
      LPF a7#get_known_spells_from_cre INT_VAR spell_type = 0 RET known_spells RET_ARRAY a7#known_spells_priest = known_spells END
      PATCH_IF (known_spells > 0) BEGIN
        SPRINT known_spells_shaman ~a7#known_spells_priest~
      END
    END
    PATCH_IF (~%memorized_spells_cleric%~ STR_EQ ~~ || ~%memorized_spells_druid%~ STR_EQ ~~) BEGIN
      LPF a7#get_memorized_spells_from_cre INT_VAR spell_type = 0 RET memorized_spells RET_ARRAY a7#memorized_spells_priest = memorized_spells END
      PATCH_IF (~%memorized_spells_cleric%~ STR_EQ ~~ && memorized_spells > 0) BEGIN
        SPRINT memorized_spells_cleric ~a7#memorized_spells_priest~
      END
      PATCH_IF (~%memorized_spells_druid%~ STR_EQ ~~ && memorized_spells > 0) BEGIN
        SPRINT memorized_spells_druid ~a7#memorized_spells_priest~
      END
    END
    PATCH_IF (~%known_spells_wizard%~ STR_EQ ~~) BEGIN
      LPF a7#get_known_spells_from_cre INT_VAR spell_type = 1 RET known_spells RET_ARRAY a7#known_spells_wizard = known_spells END
      PATCH_IF (known_spells > 0) BEGIN
        SPRINT known_spells_wizard ~a7#known_spells_wizard~
      END
    END
    PATCH_IF (~%memorized_spells_wizard%~ STR_EQ ~~) BEGIN
      LPF a7#get_memorized_spells_from_cre INT_VAR spell_type = 1 RET memorized_spells RET_ARRAY a7#memorized_spells_wizard = memorized_spells END
      PATCH_IF (memorized_spells > 0) BEGIN
        SPRINT memorized_spells_wizard ~a7#memorized_spells_wizard~
      END
    END

    // determining levels for given XP and adjusting XP for dual-classes
    LPF a7#get_class_levels
      INT_VAR xp class original_class original_level
      RET xp level1 level2 level3
    END

    // resetting class (required for class or level change)
    LPF a7#reset_class RET success END
    PATCH_IF (NOT success) BEGIN
      PATCH_FAIL ~Could not reset class~
    END
  END

  PATCH_IF (success) BEGIN
    // assigning new class/kit combination
    LPF a7#assign_class
      INT_VAR class kit remove_unusable keep_innates
      RET success
    END
    PATCH_IF (NOT success) BEGIN
      PATCH_FAIL ~Could not assign new class/kit combination~
    END
  END

  PATCH_IF (success) BEGIN
    // setting class levels/xp and calculating hit points
    LPF a7#change_cre_class_levels
      INT_VAR class level1 level2 level3 xp hp_mode original_class original_level
      RET success
    END
  END

  PATCH_IF (success) BEGIN
    // assigning thieving skill points if available
    LPF a7#change_cre_thieving_skills
      INT_VAR class kit level1 level2 level3
      STR_VAR thieving_weights
      RET success
    END
  END

  PATCH_IF (success) BEGIN
    // assigning weapon proficiencies
    // getting dominant proficiency class
    LPF a7#change_cre_proficiencies
      INT_VAR class
      STR_VAR profs_warrior profs_rogue profs_priest profs_wizard
      RET success
    END
  END

  PATCH_IF (success) BEGIN
    // setting up known and memorized spells
    LPF a7#change_cre_spells
      INT_VAR
        class kit level1 level2 level3 original_class original_level add_verbatim
      STR_VAR
        known_spells_shaman
        memorized_spells_cleric
        memorized_spells_druid
        known_spells_wizard
        memorized_spells_wizard
        known_spells_innate
        memorized_spells_innate 
      RET
        success
    END
  END
END


/**
 * Used internally by "a7#change_cre_class" to set class levels and hit points.
 *
 * INT_VAR class             Numeric identifier of the new class (CLASS.IDS). Specify -1 to keep the current class.
 *                           (Default: 0)
 * INT_VAR level1           Level of first class aspect (dual/multiclass) or single class. (Default: 0)
 * INT_VAR level2           Level of second class aspect (dual/multiclass). (Default: 0)
 * INT_VAR level3           Level of third class aspect (multiclass). (Default: 0)
 * INT_VAR xp               Experience points to assign. (Default: 0)
 * INT_VAR hp_mode          Controls how hit points are calculated. Supported modes: 0=use dice values as defined by
 *                          the HP tables, 1=calculated value is slightly below max. HP, 2=use max. HP) (Default: 1)
 * INT_VAR original_class   (Dual-class only) Numeric identifier of the original class (CLASS.IDS). Specify if the
 *                          class change doesn't involve dual-classing. (Default: 0)
 * INT_VAR original_level   (Dual-class only) Level of the original class. Value must be 2 or greater for successful
 *                          dual-classing. This value is only considered if "original_class" is set. (Default: 0)
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#change_cre_class_levels
INT_VAR
  class = 0
  level1 = 0
  level2 = 0
  level3 = 0
  xp = 0
  hp_mode = 1
  is_dualclass = 0
  original_class = 0
  original_level = 0
RET
  success
BEGIN
  LPF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
  SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : (class1 > 0) ? 1 : 0
  SET success = (num_classes > 0)
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Invalid class: %class%~
  END

  PATCH_IF (success) BEGIN
    SET is_dualclass = original_class != 0 && original_level > 1

    // setting class level and xp
    LPF a7#assign_level
      INT_VAR
        level1 level2 level3 xp
        dual = is_dualclass
        original_class
        max_hp = (hp_mode > 0)
      RET success
    END
    PATCH_IF (NOT success) BEGIN
      PATCH_FAIL ~Could not level up character~
    END
  END

  PATCH_IF (success) BEGIN
    PATCH_IF (hp_mode == 1) BEGIN
      // adjusting hp (slightly below max. hp)
      SET levels_avg = 0
      FOR (i = 1; i <= num_classes; ++i) BEGIN SET levels_avg += EVAL ~level%i%~ END
      SET levels_avg /= num_classes
      SET levels_avg = (levels_avg > 10) ? 10 : levels_avg
      WRITE_SHORT 0x24 (THIS > levels_avg ? THIS - levels_avg : THIS)  // cur. HP
      WRITE_SHORT 0x26 (THIS > levels_avg ? THIS - levels_avg : THIS)  // max. HP
    END
  END
END


/**
 * Used internally by "a7#change_cre_class" to assign thieving skills based on a map of
 * skill weights.
 *
 * INT_VAR class              Numeric identifier of the new class (CLASS.IDS). (Default: 0)
 * INT_VAR kit                Numeric indentifier of the new kit (KIT.IDS). (Default: 0)
 * INT_VAR level1             Level of first class aspect (dual/multiclass) or single class. (Default: 0)
 * INT_VAR level2             Level of second class aspect (dual/multiclass). (Default: 0)
 * INT_VAR level3             Level of third class aspect (multiclass). (Default: 0)
 * STR_VAR thieving_weights   Name of the associative array with individual weight definitions for thieving skills,
 *                            as "<skill_name>" => <weight> entries. Weight values are relative to each other.
 *                            Supported thieving skill names: "pick_pockets", "open_locks", "find_traps", "move_silently",
 *                            "hide_in_shadows", "detect_illusion", "set_traps". (Default: "thieving_weights")
 * RET success                Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#change_cre_thieving_skills
INT_VAR
  class = 0
  kit = 0
  level1 = 0
  level2 = 0
  level3 = 0
STR_VAR
  thieving_weights = ~thieving_weights~
RET
  success
BEGIN
  // assigning thieving skill points if available
  SET race = BYTE_AT 0x272
  LPF a7#calculate_thieving_skills
    INT_VAR race class kit level1 level2 level3
    RET success points_available
  END

  PATCH_IF (success && points_available > 0) BEGIN
    PATCH_FOR_EACH var IN ~pick_pockets~ ~open_locks~ ~find_traps~ ~move_silently~
                          ~hide_in_shadows~ ~detect_illusion~ ~set_traps~ BEGIN
      SET EVAL ~%var%~ = 0
    END
    SET param_count = 0
    PATCH_PHP_EACH EVAL ~%thieving_weights%~ AS var => weight BEGIN
      SET EVAL ~%var%~ = weight
      SET param_count += 1
    END
    PATCH_IF (param_count == 0) BEGIN
      PATCH_WARN ~WARNING: No thieving skill weights specified. Using default weights.~
      PATCH_FOR_EACH var IN ~pick_pockets~ ~open_locks~ ~find_traps~ ~move_silently~
                            ~hide_in_shadows~ ~detect_illusion~ ~set_traps~ BEGIN
        SET EVAL ~%var%~ = 50
      END
    END

    LPF a7#assign_thieving_skills
      INT_VAR pick_pockets open_locks find_traps move_silently hide_in_shadows detect_illusion set_traps
      RET success
    END
    PATCH_IF (NOT success) BEGIN
      PATCH_FAIL ~Could not distribute points to thieving skills~
    END
  END
END


/**
 * Used internally by "a7#change_cre_class" to assign weapon proficiencies based on the
 * given proficiency arrays.
 *
 * INT_VAR class            Numeric identifier of the new class (CLASS.IDS). (Default: 0)
 * STR_VAR profs_warrior    Name of the 0-based indexed array with proficiency labels or identifiers for warrior
 *                          classes. Entries are cumulative. It should contain enough entries to spend on the
 *                          class/level of the character. (Default: "profs_warrior")
 * STR_VAR profs_rogue      Name of the 0-based indexed array with proficiency labels or identifiers for rogue
 *                          classes. Entries are cumulative. It should contain enough entries to spend on the
 *                          class/level of the character. (Default: "profs_rogue")
 * STR_VAR profs_priest     Name of the 0-based indexed array with proficiency labels or identifiers for priest
 *                          classes. Entries are cumulative. It should contain enough entries to spend on the
 *                          class/level of the character. (Default: "profs_priest")
 * STR_VAR profs_wizard     Name of the 0-based indexed array with proficiency labels or identifiers for wizard
 *                          classes. Entries are cumulative. It should contain enough entries to spend on the
 *                          class/level of the character. (Default: "profs_wizard")
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#change_cre_proficiencies
INT_VAR
  class = 0
STR_VAR
  profs_warrior = ~profs_warrior~
  profs_rogue   = ~profs_rogue~
  profs_priest  = ~profs_priest~
  profs_wizard  = ~profs_wizard~
RET
  success
BEGIN
  LPF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
  SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : (class1 > 0) ? 1 : 0
  SET success = (num_classes > 0)
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Invalid class: %class%~
  END

  PATCH_IF (success) BEGIN
    // assigning weapon proficiencies
    // getting dominant proficiency class
    SET pref_cat = 0
    FOR (i = 1; i <= num_classes; ++i) BEGIN
      SET cur_class = EVAL ~class%i%~
      LPF a7#get_class_category INT_VAR class = cur_class RET category END
      PATCH_MATCH category WITH
        1 BEGIN // wizard
          PATCH_IF (pref_cat == 0) BEGIN SET pref_cat = 1 END
        END
        3 BEGIN // priest
          SET pref_cat = 3
        END
        4 BEGIN // rogue
          PATCH_IF (pref_cat < 2) BEGIN SET pref_cat = 4 END
        END
        DEFAULT // warrior, monk
          PATCH_IF (pref_cat != 3) BEGIN SET pref_cat = 2 END
      END
    END

    PATCH_MATCH pref_cat WITH
      1 BEGIN SPRINT proficiencies ~%profs_wizard%~ END
      3 BEGIN SPRINT proficiencies ~%profs_priest%~ END
      4 BEGIN SPRINT proficiencies ~%profs_rogue%~ END
      DEFAULT SPRINT proficiencies ~%profs_warrior%~
    END

    PATCH_PHP_EACH EVAL ~%proficiencies%~ AS index => prof_id BEGIN
      SET $proficiency(~%index%~) = prof_id
    END

    // assigning determined set of proficiencies
    LPF a7#assign_proficiencies RET success END
    PATCH_IF (NOT success) BEGIN
      PATCH_FAIL ~Could not assign weapon proficiencies~
    END
  END
END


/**
 * Used internally by "a7#change_cre_class" to assign known and memorized spells based on the
 * given parameters.
 *
 * INT_VAR class                    Numeric identifier of the new class (CLASS.IDS). (Default: 0)
 * INT_VAR kit                      Numeric identifier of the new kit (KIT.IDS). Specify -1 to keep the current kit. (Default: 0)
 * INT_VAR level1                   Level of first class aspect (dual/multiclass) or single class. (Default: 0)
 * INT_VAR level2                   Level of second class aspect (dual/multiclass). (Default: 0)
 * INT_VAR level3                   Level of third class aspect (multiclass). (Default: 0)
 * INT_VAR add_verbatim             If set then known wizard spell list is added exactly as defined. Otherwise, an additional
 *                                  compatible spell pick is added for specialist mages, and the spell list is capped at the
 *                                  current class level. (Default: 0)
 * INT_VAR original_class           (Dual-class only) Numeric identifier of the original class (CLASS.IDS). Specify if
 *                                  the class change doesn't involve dual-classing. (Default: 0)
 * INT_VAR original_level           (Dual-class only) Level of the original class. Value must be 2 or greater for successful
 *                                  dual-classing. This value is only considered if "original_class" is set. (Default: 0)
 * STR_VAR known_spells_shaman      Name of a 0-based indexed array with known spells for the Shaman class. Array
 *                                  should contain definitions for all spell levels. (Default: "known_spells_shaman")
 * STR_VAR memorized_spells_cleric  Name of a 0-based indexed array with memorizable spells for clerics and paladins.
 *                                  Array should contain definitions for all spell levels. Duplicate spell definitions
 *                                  are cumulative. (Default: "memorized_spells_cleric")
 * STR_VAR memorized_spells_druid   Name of a 0-based indexed array with memorizable spells for druids and rangers.
 *                                  Array should contain definitions for all spell levels. Duplicate spell definitions
 *                                  are cumulative. (Default: "memorized_spells_druid")
 * STR_VAR known_spells_wizard      Name of a 0-based indexed array with known spells for mages, bards and sorcerers.
 *                                  Array should contain definitions for all spell levels. (Default: "known_spells_wizard")
 * STR_VAR memorized_spells_wizard  Name of a 0-based indexed array with memorizable spells for mages and bards. Array
 *                                  should contain definitions for all spell levels. Duplicate spell definitions are
 *                                  cumulative. (Default: "memorized_spells_wizard")
 * STR_VAR known_spells_innate      Name of a 0-based indexed array with known innate spells. Array should contain
 *                                  definitions for all spell levels. (Default: "known_spells_innate")
 * STR_VAR memorized_spells_innate  Name of a 0-based indexed array with memorizable innate spells. Duplicate spell
 *                                  definitions are cumulative. (Default: "memorized_spells_innate")
 * RET success                      Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#change_cre_spells
INT_VAR
  class = 0
  kit = 0
  level1 = 0
  level2 = 0
  level3 = 0
  original_class = 0
  original_level = 0
  add_verbatim = 0
STR_VAR
  known_spells_shaman     = ~known_spells_shaman~
  memorized_spells_cleric = ~memorized_spells_cleric~
  memorized_spells_druid  = ~memorized_spells_druid~
  known_spells_wizard     = ~known_spells_wizard~
  memorized_spells_wizard = ~memorized_spells_wizard~
  known_spells_innate     = ~known_spells_innate~
  memorized_spells_innate = ~memorized_spells_innate~
RET
  success
BEGIN
  LPF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
  SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : (class1 > 0) ? 1 : 0
  SET success = (num_classes > 0)
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Invalid class: %class%~
  END

  LPF a7#get_kit_info INT_VAR kit RET kit_label kit_class kit_unusability END

  // checking whether class is a specialist mage
  SET is_dualclass = original_class != 0 && original_level > 1
  SET class_mage = IDS_OF_SYMBOL(~class~ ~MAGE~)
  SET is_specialist_mage = is_dualclass &&
                           original_class == class_mage &&
                           original_class == kit_class &&
                           (kit & SPECIALIST_MAGE_MASK) != 0
  SET cur_class = class
  FOR (i = 1; NOT is_specialist_mage && i <= num_classes; ++i) BEGIN
    SET cur_class = EVAL ~class%i%~
    SET is_specialist_mage = (cur_class == class_mage && (kit_unusability & SPECIALIST_MAGE_MASK) != 0)
  END

  SET known_spells = 0
  SET memorized_spells = 0

  SET wis = BYTE_AT 0x23b
  SET alignment = BYTE_AT 0x27b

  // assigning available spell slots
  LPF a7#calculate_spell_slots
    INT_VAR class kit level1 level2 level3 wis
    RET success
    RET_ARRAY slots_priest_memorize slots_wizard_memorize
  END
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Could not calculate spell slots~
  END

  READ_LONG 0x2a8 ofs_meminfo
  READ_LONG 0x2ac num_meminfo
  FOR (idx = 0; idx < num_meminfo; ++idx) BEGIN
    SET cur_ofs = ofs_meminfo + idx * 16
    READ_SHORT (cur_ofs + 0x06) cur_type
    PATCH_MATCH cur_type WITH
      0 BEGIN SPRINT cur_slots_memorize ~slots_priest_memorize~ END
      1 BEGIN SPRINT cur_slots_memorize ~slots_wizard_memorize~ END
      DEFAULT SPRINT cur_slots_memorize ~~
    END

    PATCH_IF (NOT ~%cur_slots_memorize%~ STR_EQ ~~) BEGIN
      SET level = (SHORT_AT cur_ofs) + 1
      SET count = $EVAL ~%cur_slots_memorize%~(~%level%~)
      WRITE_SHORT (cur_ofs + 0x02) count
      WRITE_SHORT (cur_ofs + 0x04) count
    END
  END

  // caching existing known spells
  READ_LONG 0x2a0 ofs_known_spells
  READ_LONG 0x2a4 num_known_spells
  FOR (idx = 0; idx < num_known_spells; ++idx) BEGIN
    SET cur_ofs = ofs_known_spells + idx * 12
    READ_ASCII cur_ofs resref (8) NULL
    TO_UPPER ~resref~
    LPF a7#get_spell_info STR_VAR resref RET spell_type school level exclusion END
    LPF a7#is_spell_usable INT_VAR class = cur_class kit alignment spell_type exclusion RET usable END
    SET $spell_cache(~%resref%~) = 1
    PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ ~usable~ BEGIN
      SET $spell_cache(~%resref%~ ~%var%~) = EVAL ~%var%~
    END
  END

  // handling user-defined innate abilities
  PATCH_IF (NOT ~%known_spells_innate%~ STR_EQ ~~) BEGIN
    // adding known spells
    FOR (idx = 0; VARIABLE_IS_SET $EVAL ~%known_spells_innate%~(~%idx%~); ++idx) BEGIN
      LPF a7#resolve_spell_resref STR_VAR spell = $EVAL ~%known_spells_innate%~(~%idx%~) RET resref END
      PATCH_IF (NOT ~%resref%~ STR_EQ ~~) BEGIN
        // using cache to reduce workload
        PATCH_IF (NOT VARIABLE_IS_SET $spell_cache(~%resref%~)) BEGIN
          LPF a7#get_spell_info STR_VAR resref RET spell_type school level exclusion END
          SET $spell_cache(~%resref%~) = 1
          SET $spell_cache(~%resref%~ ~usable~) = 1
          PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ BEGIN
            SET $spell_cache(~%resref%~ ~%var%~) = EVAL ~%var%~
          END
        END
        PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ ~usable~ BEGIN
          SET EVAL ~%var%~ = $spell_cache(~%resref%~ ~%var%~)
        END

        PATCH_IF (spell_type == 2) BEGIN  // innate spell
          // adding to "known spells" list
          SPRINT $known_spells(~%known_spells%~) ~%resref%~
          SET known_spells += 1
        END
      END
    END
  END

  PATCH_IF (NOT ~%memorized_spells_innate%~ STR_EQ ~~) BEGIN
    // adding memorized spells
    FOR (idx = 0; VARIABLE_IS_SET $EVAL ~%memorized_spells_innate%~(~%idx%~); ++idx) BEGIN
      LPF a7#resolve_spell_resref STR_VAR spell = $EVAL ~%memorized_spells_innate%~(~%idx%~) RET resref END
      PATCH_IF (VARIABLE_IS_SET $spell_cache(~%resref%~) && $spell_cache(~%resref%~ ~spell_type~) == 2) BEGIN
        SPRINT $memorized_spells(~%memorized_spells%~) ~%resref%~
        SET memorized_spells += 1
      END
    END
  END

  // handling wizard spells
  LPF a7#get_mage_kit_school INT_VAR unusable = kit_unusability RET kit_school = school END
  FOR (cls_idx = 1; success && cls_idx <= num_classes; ++cls_idx) BEGIN
    SET cur_class = EVAL ~class%cls_idx%~
    SET cur_level = EVAL ~level%cls_idx%~

    PATCH_MATCH cur_class WITH
      1 5 BEGIN // Mage, Bard
        // generating list of user-defined known mage spells for all levels with memorizable spell slots
        LPF a7#calculate_spell_slots
          INT_VAR
            class = cur_class
            kit
            level1 = cur_level
            wis
          RET success
          RET_ARRAY slots_wizard_memorize
        END
        PATCH_IF (NOT success) BEGIN
          PATCH_WARN ~WARNING: Could not calculate wizard spell slots~
        END

        PATCH_IF (success) BEGIN
          FOR (spl_level = 1; spl_level <= 9 && (add_verbatim || $slots_wizard_memorize(~%spl_level%~) > 0); ++spl_level) BEGIN
            SPRINT specialist_spell_resref ~~
            PATCH_IF (is_specialist_mage && NOT add_verbatim) BEGIN
              // specialist mage take first pick from specialist school
              LPF a7#get_spell_picks
                INT_VAR
                  unusable = kit_unusability
                  level = spl_level
                  count = 1
                RET spells
                RET_ARRAY spells
              END
              PATCH_IF (spells > 0) BEGIN
                SPRINT resref $spells(~0~)
                TO_UPPER ~resref~
                // using cache to reduce workload
                PATCH_IF (NOT VARIABLE_IS_SET $spell_cache(~%resref%~)) BEGIN
                  LPF a7#get_spell_info STR_VAR resref RET spell_type school level exclusion END
                  SET $spell_cache(~%resref%~) = 1
                  SET $spell_cache(~%resref%~ ~usable~) = 1
                  PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ BEGIN
                    SET $spell_cache(~%resref%~ ~%var%~) = EVAL ~%var%~
                  END
                END
                // adding to "known spells" list
                SPRINT $known_spells(~%known_spells%~) ~%resref%~
                SET known_spells += 1
                SPRINT specialist_spell_resref ~%resref%~ // checked below to prevent adding duplicate spell entries
              END
            END

            PATCH_IF (NOT ~%known_spells_wizard%~ STR_EQ ~~) BEGIN
              // adding generic spells
              FOR (idx = 0; VARIABLE_IS_SET $EVAL ~%known_spells_wizard%~(~%idx%~); ++idx) BEGIN
                LPF a7#resolve_spell_resref STR_VAR spell = $EVAL ~%known_spells_wizard%~(~%idx%~) RET resref END
                PATCH_IF (NOT ~%resref%~ STR_EQ ~~ && NOT ~%resref%~ STR_EQ ~%specialist_spell_resref%~) BEGIN
                  // using cache to reduce workload
                  PATCH_IF (NOT VARIABLE_IS_SET $spell_cache(~%resref%~)) BEGIN
                    LPF a7#get_spell_info STR_VAR resref RET spell_type school level exclusion END
                    LPF a7#is_spell_usable INT_VAR class = cur_class kit alignment spell_type exclusion RET usable END
                    SET $spell_cache(~%resref%~) = 1
                    PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ ~usable~ BEGIN
                      SET $spell_cache(~%resref%~ ~%var%~) = EVAL ~%var%~
                    END
                  END
                  PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ ~usable~ BEGIN
                    SET EVAL ~%var%~ = $spell_cache(~%resref%~ ~%var%~)
                  END

                  PATCH_IF (spell_type == 1 && level == spl_level && usable) BEGIN  // wizard spell
                    // adding to "known spells" list
                    SPRINT $known_spells(~%known_spells%~) ~%resref%~
                    SET known_spells += 1
                  END
                END
              END
            END
          END

          // generating list of user-defined memorizable mage spells for all levels with memorizable spell slots
          FOR (spl_level = 1; spl_level <= 9 && $slots_wizard_memorize(~%spl_level%~) > 0; ++spl_level) BEGIN
            // specialist mages take first pick from specialist school
            PATCH_IF (is_specialist_mage) BEGIN
              // first pick per level: specialist school spell
              FOR (idx = 0; idx < known_spells && $slots_wizard_memorize(~%spl_level%~) > 0; ++idx) BEGIN
                SPRINT resref $known_spells(~%idx%~)
                TO_UPPER ~resref~
                PATCH_IF ($spell_cache(~%resref%~ ~spell_type~) == 1 &&
                          $spell_cache(~%resref%~ ~level~) == spl_level &&
                          $spell_cache(~%resref%~ ~usable~)) BEGIN
                  SPRINT $memorized_spells(~%memorized_spells%~) ~%resref%~
                  SET memorized_spells += 1
                  SET $slots_wizard_memorize(~%spl_level%~) -= 1
                  SET idx = known_spells
                END
              END
            END

            PATCH_IF (NOT ~%memorized_spells_wizard%~ STR_EQ ~~) BEGIN
              // adding generic spells
              FOR (idx = 0; VARIABLE_IS_SET $EVAL ~%memorized_spells_wizard%~(~%idx%~); ++idx) BEGIN
                LPF a7#resolve_spell_resref STR_VAR spell = $EVAL ~%memorized_spells_wizard%~(~%idx%~) RET resref END
                PATCH_IF (VARIABLE_IS_SET $spell_cache(~%resref%~) &&
                          $spell_cache(~%resref%~ ~spell_type~) == 1 &&
                          $spell_cache(~%resref%~ ~level~) == spl_level &&
                          $spell_cache(~%resref%~ ~usable~) &&
                          $slots_wizard_memorize(~%spl_level%~) > 0) BEGIN
                  SPRINT $memorized_spells(~%memorized_spells%~) ~%resref%~
                  SET memorized_spells += 1
                  SET $slots_wizard_memorize(~%spl_level%~) -= 1
                END
              END
            END
          END
        END
      END
      19 BEGIN  // Sorcerer
        PATCH_IF (~%known_spells_wizard%~ STR_EQ ~~ || NOT VARIABLE_IS_SET $EVAL ~%known_spells_wizard%~(~0~)) BEGIN
          SET success = 0
          PATCH_WARN ~WARNING: No sorcerer spells specified~
        END

        PATCH_IF (success) BEGIN
          // generating list of user-defined known mage spells for all levels with memorizable spell slots
          LPF a7#calculate_spell_slots
            INT_VAR
              class = cur_class
              kit
              level1 = cur_level
              wis
            RET success
            RET_ARRAY slots_spells_known
          END
          PATCH_IF (NOT success) BEGIN
            PATCH_WARN ~WARNING: Could not calculate wizard spell slots~
          END
        END

        PATCH_IF (success) BEGIN
          FOR (spl_level = 1; spl_level <= 9 && $slots_spells_known(~%spl_level%~) > 0; ++spl_level) BEGIN
            FOR (idx = 0; VARIABLE_IS_SET $EVAL ~%known_spells_wizard%~(~%idx%~); ++idx) BEGIN
              SPRINT spell $EVAL ~%known_spells_wizard%~(~%idx%~)
              LPF a7#resolve_spell_resref STR_VAR spell RET resref END
              PATCH_IF (NOT ~%resref%~ STR_EQ ~~) BEGIN
                // using cache to reduce workload
                PATCH_IF (NOT VARIABLE_IS_SET $spell_cache(~%resref%~)) BEGIN
                  LPF a7#get_spell_info STR_VAR resref RET spell_type school level exclusion END
                  LPF a7#is_spell_usable INT_VAR class = cur_class kit alignment spell_type exclusion RET usable END
                  SET $spell_cache(~%resref%~) = 1
                  PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ ~usable~ BEGIN
                    SET $spell_cache(~%resref%~ ~%var%~) = EVAL ~%var%~
                  END
                END
                PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ ~usable~ BEGIN
                  SET EVAL ~%var%~ = $spell_cache(~%resref%~ ~%var%~)
                END

                // adding known/memorized spell
                PATCH_IF (VARIABLE_IS_SET $spell_cache(~%resref%~) &&
                          $spell_cache(~%resref%~ ~spell_type~) == 1 &&
                          $spell_cache(~%resref%~ ~level~) == spl_level &&
                          $spell_cache(~%resref%~ ~usable~) &&
                          $slots_spells_known(~%spl_level%~) > 0) BEGIN
                  SPRINT $known_spells(~%known_spells%~) ~%resref%~
                  SET known_spells += 1
                  SET $slots_spells_known(~%spl_level%~) -= 1
                END
              END
            END
          END
        END
      END
      DEFAULT
    END
  END

  // handling priest spells
  // determine net total of memorizable spell slots
  LPF a7#calculate_spell_slots
    INT_VAR class kit level1 level2 level3 wis
    RET success
    RET_ARRAY slots_priest_memorize
  END
  SET cleric = 0
  SET druid = 0
  SET cleric_level = 0
  SET druid_level = 0
  FOR (cls_idx = 1; cls_idx <= num_classes; ++cls_idx) BEGIN
    SET cur_class = EVAL ~class%cls_idx%~
    SET cur_level = EVAL ~level%cls_idx%~
    PATCH_MATCH cur_class WITH
      3 6 11 12 BEGIN // Cleric, Paladin, Druid, Ranger
        // initializing parameters for generating priest spell lists for all levels with memorizable spell slots
        LPF a7#calculate_spell_slots
          INT_VAR
            class = cur_class
            kit
            level1 = cur_level
            wis
          RET success
          RET_ARRAY slots_cur_class_memorize = slots_priest_memorize
        END

        PATCH_IF (success) BEGIN
          SET is_cleric = (cur_class == 3 || cur_class == 6)
          SET is_druid = (cur_class == 11 || cur_class == 12)
          SET cleric = cleric || is_cleric
          SET druid = druid || is_druid
          FOR (spl_level = 1; spl_level <= 7; ++spl_level) BEGIN
            PATCH_IF ($slots_cur_class_memorize(~%spl_level%~) > 0) BEGIN
              PATCH_IF (is_cleric) BEGIN
                SET cleric_level = (spl_level > cleric_level) ? spl_level : cleric_level
              END ELSE PATCH_IF (is_druid) BEGIN
                SET druid_level = (spl_level > druid_level) ? spl_level : druid_level
              END
            END
          END
        END ELSE BEGIN
          PATCH_WARN ~WARNING: Could not calculate priest spell slots~
        END
      END
      21 BEGIN  // Shaman
        PATCH_IF (~%known_spells_shaman%~ STR_EQ ~~ || NOT VARIABLE_IS_SET $EVAL ~%known_spells_shaman%~(~0~)) BEGIN
          SET success = 0
          PATCH_WARN ~WARNING: No shaman spells specified~
        END

        PATCH_IF (success) BEGIN
          // generating list of user-defined known shaman spells for all levels with memorizable spell slots
          LPF a7#calculate_spell_slots
            INT_VAR
              class = cur_class
              kit
              level1 = cur_level
              wis
            RET success
            RET_ARRAY slots_spells_known
          END
          PATCH_IF (NOT success) BEGIN
            PATCH_WARN ~WARNING: Could not calculate priest spell slots~
          END
        END

        PATCH_IF (success) BEGIN
          FOR (spl_level = 1; spl_level <= 7 && $slots_spells_known(~%spl_level%~) > 0; ++spl_level) BEGIN
            FOR (idx = 0; VARIABLE_IS_SET $EVAL ~%known_spells_shaman%~(~%idx%~); ++idx) BEGIN
              SPRINT spell $EVAL ~%known_spells_shaman%~(~%idx%~)
              LPF a7#resolve_spell_resref STR_VAR spell RET resref END
              PATCH_IF (NOT ~%resref%~ STR_EQ ~~) BEGIN
                // using cache to reduce workload
                PATCH_IF (NOT VARIABLE_IS_SET $spell_cache(~%resref%~)) BEGIN
                  LPF a7#get_spell_info STR_VAR resref RET spell_type school level exclusion END
                  LPF a7#is_spell_usable INT_VAR class = cur_class kit alignment spell_type exclusion RET usable END
                  SET $spell_cache(~%resref%~) = 1
                  PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ ~usable~ BEGIN
                    SET $spell_cache(~%resref%~ ~%var%~) = EVAL ~%var%~
                  END
                END
                PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ ~usable~ BEGIN
                  SET EVAL ~%var%~ = $spell_cache(~%resref%~ ~%var%~)
                END

                // adding known/memorized spell
                PATCH_IF (VARIABLE_IS_SET $spell_cache(~%resref%~) &&
                          $spell_cache(~%resref%~ ~spell_type~) == 0 &&
                          $spell_cache(~%resref%~ ~level~) == spl_level &&
                          $spell_cache(~%resref%~ ~usable~) &&
                          $slots_spells_known(~%spl_level%~) > 0) BEGIN
                  SPRINT $known_spells(~%known_spells%~) ~%resref%~
                  SET known_spells += 1
                  SET $slots_spells_known(~%spl_level%~) -= 1
                END
              END
            END
          END
        END
      END
      DEFAULT
    END
  END

  PATCH_IF (success && (cleric || druid)) BEGIN
    // generating list of known cleric/druid spells for all levels with memorizable spell slots
    LPF a7#pregen_spells_array
      INT_VAR cleric druid cleric_level druid_level alignment
      RET priest_known_spells = known_spells
      RET_ARRAY priest_known_spells = known_spells
    END

    FOR (spl_level = 1; spl_level <= 7 && $slots_priest_memorize(~%spl_level%~) > 0; ++spl_level) BEGIN
      FOR (idx = 0; idx < priest_known_spells; ++idx) BEGIN
        SPRINT resref $priest_known_spells(~%idx%~)
        TO_UPPER ~resref~
        // using cache to reduce workload
        PATCH_IF (NOT VARIABLE_IS_SET $spell_cache(~%resref%~)) BEGIN
          LPF a7#get_spell_info STR_VAR resref RET spell_type school level exclusion END
          SET $spell_cache(~%resref%~) = 1
          SET $spell_cache(~%resref%~ ~usable~) = 1
          PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ BEGIN
            SET $spell_cache(~%resref%~ ~%var%~) = EVAL ~%var%~
          END
        END
        PATCH_FOR_EACH var IN ~spell_type~ ~school~ ~level~ ~exclusion~ ~usable~ BEGIN
          SET EVAL ~%var%~ = $spell_cache(~%resref%~ ~%var%~)
        END

        PATCH_IF (spell_type == 0 && level == spl_level && usable) BEGIN
          // adding to "known spells" list
          SPRINT $known_spells(~%known_spells%~) ~%resref%~
          SET known_spells += 1
        END
      END
    END

    // generating list of user-defined memorizable priest spells for all levels with memorizable spell slots
    FOR (spl_level = 1; spl_level <= 7 && $slots_priest_memorize(~%spl_level%~) > 0; ++spl_level) BEGIN
      SET is_cleric = cleric && spl_level <= cleric_level
      SET is_druid = druid && spl_level <= druid_level

      FOR (idx = 0 available = 1; available; ++idx) BEGIN
        PATCH_IF (is_cleric && is_druid) BEGIN
          // get a mix of cleric and druid spells
          PATCH_IF (RANDOM(0 99) < 50) BEGIN
            SPRINT memorized ~%memorized_spells_druid%~
          END ELSE BEGIN
            SPRINT memorized ~%memorized_spells_cleric%~
          END
        END ELSE PATCH_IF (is_cleric) BEGIN
          // get cleric spells
          SPRINT memorized ~%memorized_spells_cleric%~
        END ELSE PATCH_IF (is_druid) BEGIN
          // get druid spells
          SPRINT memorized ~%memorized_spells_druid%~
        END ELSE BEGIN
          // no spells available
          SPRINT memorized ~~
        END

        SET available = NOT ~%memorized%~ STR_EQ ~~ && VARIABLE_IS_SET $EVAL ~%memorized%~(~%idx%~)
        PATCH_IF (available) BEGIN 
          LPF a7#resolve_spell_resref STR_VAR spell = $EVAL ~%memorized%~(~%idx%~) RET resref END
          PATCH_IF (VARIABLE_IS_SET $spell_cache(~%resref%~) &&
                    $spell_cache(~%resref%~ ~spell_type~) == 0 &&
                    $spell_cache(~%resref%~ ~level~) == spl_level &&
                    $spell_cache(~%resref%~ ~usable~) &&
                    $slots_priest_memorize(~%spl_level%~) > 0) BEGIN
            SPRINT $memorized_spells(~%memorized_spells%~) ~%resref%~
            SET memorized_spells += 1
            SET $slots_priest_memorize(~%spl_level%~) -= 1
          END
        END
      END
    END
  END

  // adding all collected known and memorized spells
  PATCH_IF (success && known_spells > 0) BEGIN
    // adding known and memorized spells according to the character class
    LPF a7#add_spells RET success END
    PATCH_IF (NOT success) BEGIN
      PATCH_FAIL ~Could not add spells~
    END
  END
END


/**
 * Resets the attributes of the current CRE (required for assigning new class and/or levels).
 * It performs the following operations depending on given parameters:
 *  - CRE base attributes (XP, HP, levels, skills, saves, flags, ...) are reset
 *  - Priest spells are removed.
 *  - Wizard spells are removed.
 *  - Innate abilities that are referenced by associated CLAB tables are removed.
 *  - All active effects with parent resource definitions are removed.
 *  - All active effects without parent resource definitions are removed, except op144 and op360 instances as well as user-specified effects.
 *
 * IMPORTANT: This function must be called before "a7#assign_class" or "a7#assign_level" can be executed.
 *
 * INT_VAR remove_known_priest      Specifies whether known priest spells should be removed. Implies removing memorized
 *                                  priest spells. (Default: 1)
 * INT_VAR remove_memorized_priest  Specifies whether memorized priest spells should be removed. (Default: 1)
 * INT_VAR remove_known_wizard      Specifies whether known wizard spells should be removed. Implies removing memorized
 *                                  wizard spells. (Default: 1)
 * INT_VAR remove_memorized_wizard  Specifies whether memorized wizard spells should be removed. (Default: 1)
 * INT_VAR remove_known_innate      Specifies whether known innate spells should be removed. Implies removing memorized
 *                                  innate spells. Only innate spells referenced by associated CLAB tables are removed unless
 *                                  "remove_innate_forced" is set. (Default: 1)
 * INT_VAR remove_memorized_innate  Specifies whether memorized innate spells should be removed. Only innate spells referenced
 *                                  by associated CLAB tables are removed unless "remove_innate_forced" is set. (Default: 1)
 * INT_VAR remove_innate_forced     Specifies whether removal of (memorized or known) innate spells should also include entries
 *                                  that are not referenced by associated CLAB tables. (Default: 0)
 * INT_VAR remove_effects           Specifies whether active effects should be removed. All effects with a parent resource and
 *                                  all effects without parent resource except opcodes 144 and 360 are removed.
 *                                  "ignore_effect" array definitions can be used to exclude more effects from removal. (Default: 1)
 * INT_VAR ignore_effect_0, ...     Optional definitions of effect opcodes to preserve. By default opcodes 144 (Disable button)
 *                                  and 360 (Ignore reputation breaking point) are preserved if they don't have a parent resource.
 * RET success                      Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#reset_class
INT_VAR
  remove_known_priest     = 1
  remove_memorized_priest = 1
  remove_known_wizard     = 1
  remove_memorized_wizard = 1
  remove_known_innate     = 1
  remove_memorized_innate = 1
  remove_innate_forced    = 0
  remove_effects          = 1
  // ignore_effect_0         = 144 // Disable button
  // ignore_effect_1         = 360 // Ignore reputation breaking point
RET
  success
BEGIN
  READ_ASCII 0 sig (8)
  SET success = ~%sig%~ STR_EQ ~CRE V1.0~
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Not a CRE file.~
  END

  // normalizing parameters
  SET remove_memorized_priest = remove_memorized_priest || remove_known_priest
  SET remove_memorized_wizard = remove_memorized_wizard || remove_known_wizard
  SET remove_memorized_innate = remove_memorized_innate || remove_known_innate

  // removing active effects *with* parent resource
  PATCH_IF (success && remove_effects) BEGIN
    LPF a7#delete_cre_effect
      INT_VAR use_regexp = 1
      STR_VAR match_effsource = ~.+~
    END
  END

  // removing active effects *without* parent resource, except blacklisted opcodes
  PATCH_IF (success && remove_effects) BEGIN
    // initializing effects blacklist
    SET $blacklist(~144~) = 1 // Disable Button
    SET $blacklist(~360~) = 1 // Ignore Reputation Breaking Point
    FOR (i = 0; VARIABLE_IS_SET $ignore_effect(~%i%~); ++i) BEGIN
      SET opcode = $ignore_effect(~%i%~)
      SET $blacklist(~%opcode%~) = 1
    END

    SET eff_v2 = (BYTE_AT 0x33) == 1
    SET eff_size = eff_v2 ? 264 : 48
    READ_LONG 0x2c4 ofs_effects
    SET done = 0
    WHILE (NOT done) BEGIN
      READ_LONG 0x2c8 num_effects
      SET done = (num_effects == 0)
      FOR (idx = num_effects - 1; idx >= 0; --idx) BEGIN
        SET done = (idx == 0)
        SET cur_ofs = ofs_effects + idx * eff_size
        SET opcode = eff_v2 ? LONG_AT (cur_ofs + 8) : SHORT_AT cur_ofs
        PATCH_IF (NOT VARIABLE_IS_SET $blacklist(~%opcode%~)) BEGIN
          LPF a7#delete_cre_effect
            INT_VAR match_opcode = opcode
            STR_VAR match_effsource = ~~
          END
          SET idx = "-1"
        END
      END
    END
  END

  // removing spells and innates
  PATCH_IF (success) BEGIN
    READ_BYTE 0x273 class
    SET kit = ((SHORT_AT 0x244) << 16) | (SHORT_AT 0x246)

    READ_LONG 0x2a0 ofs_known
    SET done = 0
    WHILE (NOT done) BEGIN
      READ_LONG 0x2a4 num_known
      SET done = (num_known == 0)
      FOR (idx = num_known - 1; idx >= 0; --idx) BEGIN
        SET done = (idx == 0)
        SET cur_ofs = ofs_known + idx * 12
        READ_ASCII cur_ofs resref (8) NULL
        READ_SHORT (cur_ofs + 0x0a) type
        PATCH_IF (type == 0 && (remove_known_priest || remove_memorized_priest)) BEGIN
          // priest spell: remove memorized and known instances
          SET idx = "-1"
          PATCH_IF (remove_memorized_priest) BEGIN
            LPF a7#remove_memorized_spell STR_VAR resref END
          END
          PATCH_IF (remove_known_priest) BEGIN
            LPF a7#remove_known_spell STR_VAR resref END
          END
        END ELSE PATCH_IF (type == 1 && (remove_known_wizard || remove_memorized_wizard)) BEGIN
          // wizard spell: remove memorized and known instances
          SET idx = "-1"
          PATCH_IF (remove_memorized_wizard) BEGIN
            LPF a7#remove_memorized_spell STR_VAR resref END
          END
          PATCH_IF (remove_known_wizard) BEGIN
            LPF a7#remove_known_spell STR_VAR resref END
          END
        END ELSE PATCH_IF (type == 2 && (remove_known_innate || remove_memorized_innate)) BEGIN
          // innate ability: remove if referenced by CLAB (class/kit) or QD_xxx spell (multi-kit)
          PATCH_IF (remove_innate_forced) BEGIN
            SET found = 1
          END ELSE BEGIN
            LPF a7#is_innate_defined INT_VAR class kit STR_VAR innate_resref = EVAL ~%resref%~ RET found END
          END
          PATCH_IF (found) BEGIN
            SET idx = "-1"
            PATCH_IF (remove_memorized_innate) BEGIN
              LPF a7#remove_memorized_spell STR_VAR resref END
            END
            PATCH_IF (remove_known_innate) BEGIN
              LPF a7#remove_known_spell STR_VAR resref END
            END
          END
        END
      END
    END

    // removing memorized spell slots
    READ_LONG 0x2a8 ofs_meminfo
    READ_LONG 0x2ac num_meminfo
    FOR (i = 0; i < num_meminfo; ++i) BEGIN
      SET cur_ofs = ofs_meminfo + i * 16
      READ_LONG (cur_ofs + 0x0c) count
      WRITE_SHORT (cur_ofs + 0x02) (THIS > count ? count : THIS)
      WRITE_SHORT (cur_ofs + 0x04) (THIS > count ? count : THIS)
    END
  END

  // resetting CRE fields
  PATCH_IF (success) BEGIN
    // Fields to reset
    DEFINE_ASSOCIATIVE_ARRAY cre_fields BEGIN
      // offset, size => value
      0x18, 4 => 0  // XP
      0x24, 2 => 0  // Cur. HP
      0x26, 2 => 0  // Max. HP
      0x44, 1 => 0  // Reputation
      0x45, 1 => 0  // Hide in Shadows
      0x46, 2 => 10 // Natural AC
      0x48, 2 => 10 // Effective AC
      0x4a, 2 => 0  // Crushing AC modifier
      0x4c, 2 => 0  // Missile AC modifier
      0x4e, 2 => 0  // Piercing AC modifier
      0x50, 2 => 0  // Slashing AC modifier
      0x52, 1 => 20 // THAC0
      0x53, 1 => 1  // Attacks/round
      0x54, 1 => 20 // Save vs. death
      0x55, 1 => 20 // Save vs. wand
      0x56, 1 => 20 // Save vs. polymorph
      0x57, 1 => 20 // Save vs. breath
      0x58, 1 => 20 // Save vs. spell
      0x59, 1 => 0  // Fire resistance
      0x5a, 1 => 0  // Cold resistance
      0x5b, 1 => 0  // Electricity resistance
      0x5c, 1 => 0  // Acid resistance
      0x5d, 1 => 0  // Magic resistance
      0x5e, 1 => 0  // Magic fire resistance
      0x5f, 1 => 0  // Magic cold resistance
      0x60, 1 => 0  // Slashing resistance
      0x61, 1 => 0  // Crushing resistance
      0x62, 1 => 0  // Piercing resistance
      0x63, 1 => 0  // Missile resistance
      0x64, 1 => 0  // Detect Illusion
      0x65, 1 => 0  // Set Traps
      0x66, 1 => 0  // Lore
      0x67, 1 => 0  // Open Locks
      0x68, 1 => 0  // Move Silently
      0x69, 1 => 0  // Find Traps
      0x6a, 1 => 0  // Pick Pockets
      0x6b, 1 => 0  // Fatigue
      0x6c, 1 => 0  // Intoxication
      0x6d, 1 => 0  // Luck
      0x6e, 1 => 0  // Large Sword proficiency
      0x6f, 1 => 0  // Small Sword proficiency
      0x70, 1 => 0  // Bow proficiency
      0x71, 1 => 0  // Spear proficiency
      0x72, 1 => 0  // Blunt proficiency
      0x73, 1 => 0  // Spiked proficiency
      0x74, 1 => 0  // Axe proficiency
      0x75, 1 => 0  // Missile proficiency
      0x82, 1 => 0  // Turn Undead level
      0x83, 1 => 0  // Tracking
      0x234, 1 => 0 // Level 1
      0x235, 1 => 0 // Level 2
      0x236, 1 => 0 // Level 3
    END

    // resetting fields
    PHP_EACH cre_fields AS header => value BEGIN
      SET offset = $header(~0~)
      SET size = $header(~1~)
      PATCH_MATCH size WITH
        1 BEGIN WRITE_BYTE offset value END
        2 BEGIN WRITE_SHORT offset value END
        4 BEGIN WRITE_LONG offset value END
        DEFAULT
      END
    END

    // resetting dual-classing and fallen class flags
    SET status_mask = BIT3 | BIT4 | BIT5 | BIT6 | BIT7 | BIT8 | BIT9 | BIT10
    WRITE_LONG 0x10 (THIS BAND BNOT status_mask)
  END
END


/**
 * Assigns a new class with optional kit to the current CRE.
 * The CRE must have been reset by the function "a7#reset_class".
 *
 * INT_VAR class            Id of the new class to assign. Specify -1 to keep the current class. (Default: -1)
 * INT_VAR kit              Id of the kit to assign. Specify -1 to keep the current kit. (Default: -1)
 * INT_VAR remove_unusable  Specifies whether items that are unusable by the new class/kit combination should be
 *                          unequipped and placed into the inventory. Undroppable items are not affected. (Default: 1)
 * INT_VAR keep_innates     Specifies whether innate abilities without references to CLAB tables should be retained
 *                          by a class/kit change. At this point it should mostly concern character-specific innates.
 *                          (Default: 1)
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#assign_class
INT_VAR
  class = "-1"
  kit = "-1"
  remove_unusable = 1
  keep_innates = 1
RET
  success
BEGIN
  READ_ASCII 0 sig (8)
  SET success = ~%sig%~ STR_EQ ~CRE V1.0~
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Not a CRE file.~
  END

  PATCH_IF (success) BEGIN
    SET success = (class != 0 && class < 22)
    PATCH_IF (NOT success) BEGIN
      PATCH_WARN ~WARNING: Invalid class: %class%~
    END
  END

  PATCH_IF (success && kit > 0 && kit != TRUECLASS) BEGIN
    LPF a7#get_kit_info INT_VAR kit RET kit_label kit_class END
    SET success = (kit_class > 0)
    PATCH_IF (NOT success) BEGIN
      PATCH_WARN ~WARNING: Invalid kit: %kit%~
    END
  END

  PATCH_IF (success) BEGIN
    LPF a7#validate_reset RET success END
    PATCH_IF (NOT success) BEGIN
      PATCH_WARN ~WARNING: CRE has not been reset~
    END
  END

  PATCH_IF (success) BEGIN
    // get current class/kit
    READ_BYTE 0x273 cur_class
    SET cur_kit = ((SHORT_AT 0x244) << 16) | (SHORT_AT 0x246)

    SET change = (class > 0 && cur_class != class) || (kit != "-1" && cur_kit != kit)
    PATCH_IF (change) BEGIN
      // performing class/kit switch
      PATCH_IF (class > 0) BEGIN
        WRITE_BYTE 0x273 class
      END
      PATCH_IF (kit != "-1") BEGIN
        WRITE_SHORT 0x244 (kit >> 16) & 0xffff
        WRITE_SHORT 0x246 kit & 0xffff
      END

      // updating avatar
      SET race = BYTE_AT 0x272
      SET gender = BYTE_AT 0x275
      LPF a7#get_animation_id INT_VAR  race gender class RET id END
      WRITE_LONG 0x28 id

      // removing innate abilities
      PATCH_IF (NOT keep_innates) BEGIN
        LPF a7#remove_memorized_spell INT_VAR use_regexp = 1 STR_VAR resref = ~.*~ END
        LPF a7#remove_known_spell INT_VAR use_regexp = 1 STR_VAR resref = ~.*~ END
      END

      // moving or removing unusable items
      PATCH_IF (remove_unusable) BEGIN
        LPF a7#validate_equipped_items INT_VAR move_to_inventory = 1 remove_item = 1 force_move = 0 END
      END
    END
  END
END


/**
 * Sets the level of the current CRE to the specified value. This function works only if the current CRE had been reset
 * by the function "a7#reset_class". The character's base attribute, such as hp, thac0, lore, and saving throws, are adapted
 * to the new character level(s) according to the current game's progression tables.
 *
 * INT_VAR level1           Level of the first class. Use this for single-class characters or for the first class aspect of
 *                          multi- or dualclass characters (e.g. for FIGHTER_MAGE_THIEF this is "FIGHTER").
 *                          Specify -1 to keep current value. (Default: -1)
 * INT_VAR level2           Level of the second class. Use this for the second class aspect of multi- or dualclass characters
 *                          (e.g. for FIGHTER_MAGE_THIEF this is "MAGE"). Specify -1 to keep current value. (Default: -1)
 * INT_VAR level3           Level of the third class. Use this for the third class aspect of multiclass characters
 *                          (e.g. for FIGHTER_MAGE_THIEF this is "THIEF"). Specify -1 to keep current value. (Default: -1)
 * INT_VAR xp               New experience points. Setting this value does not change levels or other attributes of the creature.
 *                          Specify -1 to keep current value. (Default: -1)
 * INT_VAR dual             Specify 1 to turn a class combination of two classes into a dualclass. (Default: 0)
 * INT_VAR original_class   Id of the class aspect that should stop advancing in levels. It must be specified if the "dual" parameter is 1.
 * INT_VAR max_hp           Specifies whether max. HP per level should be calculated. (Default: 1)
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#assign_level
INT_VAR
  level1 = "-1"
  level2 = "-1"
  level3 = "-1"
  xp = "-1"
  dual = 0
  original_class = "-1"
  max_hp = 1
RET
  success
BEGIN
  READ_ASCII 0 sig (8)
  SET success = ~%sig%~ STR_EQ ~CRE V1.0~
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Not a CRE file.~
  END

  PATCH_IF (success) BEGIN
    LPF a7#validate_reset RET success END
    PATCH_IF (NOT success) BEGIN
      PATCH_WARN ~WARNING: CRE has not been reset~
    END
  END

  PATCH_IF (success) BEGIN
    READ_BYTE 0x272 race
    READ_BYTE 0x273 class
    SET kit = ((SHORT_AT 0x244) << 16) | (SHORT_AT 0x246)

    // setting xp
    SET xp = (xp < 0) ? 0 : xp
    WRITE_LONG 0x18 xp

    // setting levels
    LPF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1
    SET is_dualclass = (num_classes == 2) && dual && (original_class > 0)
    SET dual_confirmed = 0
    FOR (i = 1; i <= 3; ++i) BEGIN
      SET cur_class = EVAL ~class%i%~
      SET cur_level = EVAL ~level%i%~
      PATCH_IF (cur_class > 0 && cur_level >= 0) BEGIN
        WRITE_BYTE (0x233 + i) cur_level
        SET dual_confirmed = dual_confirmed || (is_dualclass && cur_class == original_class && cur_level > 1)
      END
    END

    // clearing old dualclass flags
    SET dual_mask = BIT3 | BIT4 | BIT5 | BIT6 | BIT7 | BIT8
    WRITE_LONG 0x10 (THIS BAND BNOT dual_mask)

    PATCH_IF (dual && dual_confirmed) BEGIN
      PATCH_MATCH original_class WITH
        1  BEGIN SET flag = BIT4 END  // Mage
        2  BEGIN SET flag = BIT3 END  // Fighter
        3  BEGIN SET flag = BIT5 END  // Cleric
        4  BEGIN SET flag = BIT6 END  // Thief
        11 BEGIN SET flag = BIT7 END  // Druid
        12 BEGIN SET flag = BIT8 END  // Ranger
        DEFAULT
          SET success = 0
          PATCH_WARN ~WARNING: Could not determine original class for dual-classing~
      END
      PATCH_IF (success) BEGIN
        // setting new "original class" flag
        WRITE_LONG 0x10 (THIS BOR flag)
      END
    END ELSE PATCH_IF (dual && NOT dual_confirmed) BEGIN
      SET success = 0
      PATCH_WARN ~WARNING: Invalid original class or level for dual-classing specified~
    END
  END

  PATCH_IF (success) BEGIN
    READ_BYTE 0x234 level1
    READ_BYTE 0x235 level2
    READ_BYTE 0x236 level3
    SET original_class = (LONG_AT 0x10) & (BIT3 | BIT4 | BIT5 | BIT6 | BIT7 | BIT8)
    PATCH_IF (original_class != 0) BEGIN
      LPF a7#evaluate_original_class INT_VAR class original_class RET original_class END
    END

    // updating HP
    LPF a7#calculate_hitpoints
      INT_VAR class kit level1 level2 level3 original_class max_hp
      RET success hp
    END
    PATCH_IF (success) BEGIN
      WRITE_SHORT 0x24 hp
      WRITE_SHORT 0x26 hp
    END ELSE BEGIN
      PATCH_WARN ~WARNING: Could not determine hitpoints~
    END
  END

  PATCH_IF (success) BEGIN
    // updating effective AC and AC modifiers
    LPF a7#calculate_ac
      INT_VAR class kit level1 level2 level3
      RET success ac_base ac_crushing ac_missile ac_piercing ac_slashing
    END
    PATCH_IF (success) BEGIN
      WRITE_SHORT 0x48 ac_base
      WRITE_SHORT 0x4a ac_crushing
      WRITE_SHORT 0x4c ac_missile
      WRITE_SHORT 0x4e ac_piercing
      WRITE_SHORT 0x50 ac_slashing
    END ELSE BEGIN
      PATCH_WARN ~WARNING: Could not determine effective AC~
    END
  END

  PATCH_IF (success) BEGIN
    // updating THAC0
    LPF a7#calculate_thac0
      INT_VAR class kit level1 level2 level3
      RET success thac0
    END
    PATCH_IF (success) BEGIN
      WRITE_BYTE 0x52 thac0
    END ELSE BEGIN
      PATCH_WARN ~WARNING: Could not determine THAC0~
    END
  END

  PATCH_IF (success) BEGIN
    // updating Lore
    LPF a7#calculate_lore
      INT_VAR class level1 level2 level3 
      RET success lore
    END
    PATCH_IF (success) BEGIN
      WRITE_BYTE 0x66 lore
    END ELSE BEGIN
      PATCH_WARN ~WARNING: Could not determine Lore~
    END
  END

  PATCH_IF (success) BEGIN
    // updating Saving Throws
    READ_BYTE 0x23d con
    LPF a7#calculate_saving_throws
      INT_VAR race class con level1 level2 level3
      RET success save_death save_wands save_poly save_breath save_spell
    END
    PATCH_IF (success) BEGIN
      SET offset = 0x54
      PATCH_FOR_EACH var IN save_death save_wands save_poly save_breath save_spell BEGIN
        SET value = EVAL ~%var%~
        WRITE_BYTE offset value
        SET offset += 1
      END
    END ELSE BEGIN
      PATCH_WARN ~WARNING: Could not determine Saving Throws~
    END
  END
END


/**
 * Distributes points to thieving skills in the current CRE according to the specified parameters.
 *
 * INT_VAR pick_pockets         Relative weight value for the "Pick Pockets" skill to determine the effective skill score.
 *                              It is only relevant for class/kit combinations that allow to assign points to that skill. (Default: 50)
 * INT_VAR open_locks           Relative weight value for the "Open Locks" skill to determine the effective skill score.
 *                              It is only relevant for class/kit combinations that allow to assign points to that skill. (Default: 50)
 * INT_VAR find_traps           Relative weight value for the "Find Traps" skill to determine the effective skill score.
 *                              It is only relevant for class/kit combinations that allow to assign points to that skill. (Default: 50)
 * INT_VAR move_silently        Relative weight value for the "Move Silently" skill to determine the effective skill score.
 *                              It is only relevant for class/kit combinations that allow to assign points to that skill. (Default: 50)
 * INT_VAR hide_in_shadows      Relative weight value for the "Hide in Shadows" skill to determine the effective skill score.
 *                              It is only relevant for class/kit combinations that allow to assign points to that skill. (Default: 50)
 * INT_VAR detect_illusion      Relative weight value for the "Detect Illusion" skill to determine the effective skill score.
 *                              It is only relevant for class/kit combinations that allow to assign points to that skill. (Default: 50)
 * INT_VAR set_traps            Relative weight value for the "Set Traps" skill to determine the effective skill score.
 *                              It is only relevant for class/kit combinations that allow to assign points to that skill. (Default: 50)
 * INT_VAR pick_pockets_cap     Specifies the max. score for the "Pick Pockets" skill to assign. (Default: 250)
 * INT_VAR open_locks_cap       Specifies the max. score for the "Open Locks" skill to assign. (Default: 100)
 * INT_VAR find_traps_cap       Specifies the max. score for the "Find Traps" skill to assign. (Default: 100)
 * INT_VAR move_silently_cap    Specifies the max. score for the "Move Silently" skill to assign. (Default: 250)
 * INT_VAR hide_in_shadows_cap  Specifies the max. score for the "Hide in Shadows" skill to assign. (Default: 250)
 * INT_VAR detect_illusion_cap  Specifies the max. score for the "Detect Illusion" skill to assign. (Default: 100)
 * INT_VAR set_traps_cap        Specifies the max. score for the "Set Traps" skill to assign. (Default: 100)
 * INT_VAR skill_granularity    Controls the granularity of thieving skill point distribution. Points will be distributed
 *                              as multiples of this value. Supported range: [1, 25]. (Default: 5)
 * RET success                  Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#assign_thieving_skills
INT_VAR
  pick_pockets = 50
  open_locks = 50
  find_traps = 50
  move_silently = 50
  hide_in_shadows = 50
  detect_illusion = 50
  set_traps = 50
  pick_pockets_cap = 250
  open_locks_cap = 100
  find_traps_cap = 100
  move_silently_cap = 250
  hide_in_shadows_cap = 250
  detect_illusion_cap = 100
  set_traps_cap = 100
  skill_granularity = 5
RET
  success
BEGIN
  READ_ASCII 0 sig (8)
  SET success = ~%sig%~ STR_EQ ~CRE V1.0~
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Not a CRE file.~
  END

  PATCH_IF (success) BEGIN
    // fetching required information
    READ_BYTE 0x272 race
    READ_BYTE 0x273 class
    SET kit = ((SHORT_AT 0x244) << 16) | (SHORT_AT 0x246)
    READ_BYTE 0x234 level1
    READ_BYTE 0x235 level2
    READ_BYTE 0x236 level3

    // preparing skill caps
    PATCH_FOR_EACH cap IN ~pick_pockets_cap~ ~open_locks_cap~ ~find_traps_cap~ ~move_silently_cap~ ~hide_in_shadows_cap~ ~detect_illusion_cap~ ~set_traps_cap~ BEGIN
      SET value = EVAL ~%cap%~
      SET value = (value < 0) ? 0 : (value > 255) ? 255 : value
      SET $skill_cap(~%cap%~) = value
    END

    // preparing skill weights
    PATCH_FOR_EACH skill IN ~pick_pockets~ ~open_locks~ ~find_traps~ ~move_silently~ ~hide_in_shadows~ ~detect_illusion~ ~set_traps~ BEGIN
      SET value = EVAL ~%skill%~
      SET value = (value < 0) ? 0 : value
      SET $skill_weight(~%skill%~) = value
    END

    // calculating thieving skills
    LPF a7#calculate_thieving_skills
      INT_VAR race class kit level1 level2 level3
      RET success points_available pick_pockets open_locks find_traps move_silently hide_in_shadows detect_illusion set_traps
    END
    PATCH_IF (NOT success) BEGIN
      PATCH_WARN ~WARNING: Could not determine thieving skills~
    END
  END

  PATCH_IF (success) BEGIN
    PATCH_DEFINE_ASSOCIATIVE_ARRAY skills_map BEGIN
      // variable name  => CRE offset
      ~pick_pockets~    => 0x6a
      ~open_locks~      => 0x67
      ~find_traps~      => 0x69
      ~move_silently~   => 0x68
      ~hide_in_shadows~ => 0x45
      ~detect_illusion~ => 0x64
      ~set_traps~       => 0x65
    END

    PATCH_IF (points_available > 0) BEGIN
      // distributing skill points

      // counting available thieving skills
      SET weight_total = 0
      SET num_available = 0
      PATCH_PHP_EACH skills_map AS var => _ BEGIN
        SET is_available = (EVAL ~%var%~ >= 0)
        PATCH_IF (is_available) BEGIN
          SET num_available += 1
          SET weight_total += $skill_weight(~%var%~)
        END
      END

      // rounding scores to a multiple of this value
      SET skill_granularity = (skill_granularity < 1) ? 1 : (skill_granularity > 25) ? 25 : skill_granularity
      // rounding threshold in positive direction
      SET skill_modifier = skill_granularity / 2

      // distributing skill points
      PATCH_IF (weight_total > 0 && num_available > 0) BEGIN
        SET points_remaining = points_available
        SET mode = 0  // indcates first distribution pass
        WHILE (points_remaining > 0) BEGIN
          PATCH_PHP_EACH skills_map AS var => offset BEGIN
            SET is_available = (EVAL ~%var%~ >= 0)
            PATCH_IF (is_available && points_remaining > 0) BEGIN
              SET cap = $skill_cap(~%var%_cap~)
              SET weight = $skill_weight(~%var%~)
              PATCH_IF (mode == 0 || weight > 0) BEGIN
                // always perform on first pass, on non-zero weights otherwise
                SET score = (weight * points_available / weight_total) + skill_modifier
                SET score -= score MODULO skill_granularity
                SET score = (score > points_remaining) ? points_remaining : score
                PATCH_IF (score > cap) BEGIN
                  // don't distribute more points to this skill
                  SET score = cap
                  SET weight_total -= $skill_weight(~%var%~)
                  SET $skill_weight(~%var%~) = 0
                END
                PATCH_IF (mode == 0) BEGIN
                  // only on first pass
                  WRITE_BYTE offset score
                END ELSE BEGIN
                  READ_BYTE offset cur_value
                  // ensure the resulting value doesn't exceed max. range
                  SET score = (cur_value + score > cap) ? cap - cur_value : score
                  WRITE_BYTE offset (THIS + score)
                END
                SET points_remaining -= score
              END
            END
          END

          SET points_available = points_remaining

          // break cycle in two steps if no more points can be distributed
          PATCH_IF (mode == points_remaining) BEGIN
            PATCH_IF (skill_modifier < skill_granularity) BEGIN
              // shift rounding modifier towards higher values
              SET skill_modifier = skill_granularity
            END ELSE BEGIN
              // terminate while-loop
              SET points_remaining = 0
            END
          END

          SET mode = points_remaining
        END
      END
    END ELSE BEGIN
      // assigning auto-calculated thieving points
      PATCH_PHP_EACH skills_map AS var => offset BEGIN
        SET score = EVAL ~%var%~
        WRITE_BYTE offset score
      END
    END
  END
END


/**
 * Builds an indexed array with proficiency values from the proficiency effects defined in the current CRE resource.
 *
 * RET profs_array        Number of entries in the array.
 * RET_ARRAY profs_array  Indexed array of weapon proficiencies (index => proficiency id).
 */
DEFINE_PATCH_FUNCTION a7#get_profs_from_cre
RET
  profs_array
RET_ARRAY
  profs_array
BEGIN
  // collecting proficiencies from current CRE
  SET effects_map = 0
  READ_LONG 0x2c4 ofs_effects
  READ_LONG 0x2c8 num_effects
  SET eff_v2 = BYTE_AT 0x33
  SET eff_size = eff_v2 ? 264 : 48
  FOR (i = 0; i < num_effects; ++i) BEGIN
    SET cur_ofs = ofs_effects + i * eff_size
    SET opcode = eff_v2 ? LONG_AT (cur_ofs + 0x08) : SHORT_AT cur_ofs
    PATCH_IF (opcode == 233) BEGIN
      SET stars = eff_v2 ? LONG_AT (cur_ofs + 0x14) : LONG_AT (cur_ofs + 0x04)
      SET stars_total = (stars & 7) + ((stars >> 3) & 7)  // active class and original class
      SET prof_id = eff_v2 ? SHORT_AT (cur_ofs + 0x18) : SHORT_AT (cur_ofs + 0x08)
      SET $effects_map(~%effects_map%~ ~id~) = prof_id
      SET $effects_map(~%effects_map%~ ~count~) = stars_total
      SET effects_map += 1
    END
  END

  // creating new profs array
  SET profs_array = 0
  SET match = 1
  WHILE (match) BEGIN
    SET match = 0
    FOR (i = 0; i < effects_map; ++i) BEGIN
      SET id = $effects_map(~%i%~ ~id~)
      SET count = $effects_map(~%i%~ ~count~)
      PATCH_IF (count > 0) BEGIN
        SET $profs_array(~%profs_array%~) = id
        SET profs_array += 1
        SET $effects_map(~%i%~ ~count~) = count - 1
        SET match = 1
      END
    END
  END
END


/**
 * Removes current proficiency definitions and applies the specified number of proficiencies to the current CRE.
 *
 * INT_VAR proficiency_0, proficiency_1, ...  Numeric proficiency values to assign points to. Each individual entry
 *                                            adds a single point to the specified weapon proficiency or style.
 *                                            Multiple definitions of the same proficiency type are cumulative.
 *                                            The function assigns only as many points as are available for the CRE
 *                                            at the current level.
 * RET success                                Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#assign_proficiencies
INT_VAR
  // proficiency_0 = IDS_OF_SYMBOL(~stats~ ~PROFICIENCYCLUB~)
  // proficiency_1 = ...
  // ...
RET
  success
BEGIN
  READ_ASCII 0 sig (8)
  SET success = ~%sig%~ STR_EQ ~CRE V1.0~
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Not a CRE file.~
  END

  PATCH_IF (success) BEGIN
    // fetching required information
    READ_BYTE 0x272 race
    READ_BYTE 0x273 class
    SET kit = ((SHORT_AT 0x244) << 16) | (SHORT_AT 0x246)
    READ_BYTE 0x234 level1
    READ_BYTE 0x235 level2
    READ_BYTE 0x236 level3
    SET original_class = (LONG_AT 0x10) & (BIT3 | BIT4 | BIT5 | BIT6 | BIT7 | BIT8)
    PATCH_IF (original_class != 0) BEGIN
      LPF a7#evaluate_original_class INT_VAR class original_class RET original_class END
    END

    // removing existing proficiency effects
    LPF a7#delete_cre_effect INT_VAR match_opcode = 233 END

    // getting supported profs and prof points
    LPF a7#calculate_proficiencies
      INT_VAR class kit level1 level2 level3 original_class
      RET success points_available
      RET_ARRAY supported_profs = proficiencies
    END
    PATCH_IF (NOT success) BEGIN
      PATCH_WARN ~WARNING: Could not determine supported proficiencies~
    END
  END

  PATCH_IF (success) BEGIN
    // collecting proficiency point assignments
    FOR (idx = 0; points_available > 0 && VARIABLE_IS_SET $proficiency(~%idx%~); ++idx) BEGIN
      PATCH_IF (IS_AN_INT $proficiency(~%idx%~)) BEGIN
        SET stat = $proficiency(~%idx%~)
        PATCH_IF (points_available > 0 && VARIABLE_IS_SET $supported_profs(~%stat%~) && $supported_profs(~%stat%~) > 0) BEGIN
          SET value = VARIABLE_IS_SET $assigned_prof(~%stat%~) ? $assigned_prof(~%stat%~) : 0
          SET value += 1
          SET $assigned_prof(~%stat%~) = value
          SET $supported_profs(~%stat%~) -= 1
          SET points_available -= 1
        END
      END
    END

    PATCH_PHP_EACH assigned_prof AS stat => value BEGIN
      // adding proficiency definition with number of "points" in active class for "prof_id"
      LPF a7#add_cre_effect
        INT_VAR
          opcode = 233  // Modify proficiencies
          parameter1 = value
          parameter2 = stat
          timing = 9
      END
    END
  END
END


/**
 * Returns whether the current CRE has been successfully reset. This state is required for functions like
 * "a7#assign_class" or "a7#assign_level".
 *
 * RET success  Returns 1 if the current CRE is in a reset state, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#validate_reset
RET
  success
BEGIN
  // xp
  READ_LONG 0x18 xp
  SET success = (xp == 0)

  PATCH_IF (success) BEGIN
    // cur/max hp
    READ_LONG 0x24 hp_all
    SET success = (hp_all == 0)
  END

  PATCH_IF (success) BEGIN
    // level 1/2/3
    FOR (i = 0; success && i < 3; ++i) BEGIN
      READ_BYTE (0x234 + i) level
      SET success = (level == 0)
    END
  END
END


/**
 * Builds an indexed array with spell resrefs from the known spells section of the current CRE resource.
 *
 * INT_VAR spell_type       The spell type to include (0=priest, 1=wizard, 2=innate). (Default: 0)
 * RET known_spells         Number of entries in the array.
 * RET_ARRAY known_spells   Indexed array of spell resrefs (index => resref).
 */
// DEFINE_PATCH_FUNCTION a7#get_known_shaman_spells_from_cre
DEFINE_PATCH_FUNCTION a7#get_known_spells_from_cre
INT_VAR
  spell_type = 0
RET
  known_spells
RET_ARRAY
  known_spells
BEGIN
  SET known_spells = 0

  SET known_size = 12
  READ_LONG 0x2a0 ofs_known
  READ_LONG 0x2a4 num_known
  FOR (i = 0; i < num_known; ++i) BEGIN
    SET cur_ofs = ofs_known + i * known_size
    READ_SHORT (cur_ofs + 0x0a) type
    PATCH_IF (type == spell_type) BEGIN
      READ_ASCII cur_ofs resref (8) NULL
      PATCH_IF (NOT ~%resref%~ STR_EQ ~~) BEGIN
        SPRINT $known_spells(~%known_spells%~) ~%resref%~
        SET known_spells += 1
      END
    END
  END
END


/**
 * Builds an indexed array with spell resrefs from the memorized spells section of the current CRE resource.
 *
 * INT_VAR spell_type       The spell type to include (0=priest, 1=wizard, 2=innate). (Default: 0)
 * RET known_spells         Number of entries in the array.
 * RET_ARRAY known_spells   Indexed array of spell resrefs (index => resref).
 */
DEFINE_PATCH_FUNCTION a7#get_memorized_spells_from_cre
INT_VAR
  spell_type = 0
RET
  memorized_spells
RET_ARRAY
  memorized_spells
BEGIN
  SET memorized_spells = 0

  // checking class features
  READ_BYTE 0x273 class
  SET is_spontaneous = (spell_type == 0 && class == IDS_OF_SYMBOL(~class~ ~SHAMAN~)) ||
                       (spell_type == 1 && class == IDS_OF_SYMBOL(~class~ ~SORCERER~))

  SET meminfo_size = 16
  SET memspell_size = 12
  READ_LONG 0x2a8 ofs_meminfo
  READ_LONG 0x2ac num_meminfo
  READ_LONG 0x2b0 ofs_memspells
  FOR (i = 0; i < num_meminfo; ++i) BEGIN
    SET cur_meminfo_ofs = ofs_meminfo + i * meminfo_size
    READ_SHORT (cur_meminfo_ofs + 0x06) type
    PATCH_IF (type == spell_type) BEGIN
      READ_SHORT (cur_meminfo_ofs + 0x08) idx_spells
      READ_SHORT (cur_meminfo_ofs + 0x0c) num_spells

      PATCH_IF (is_spontaneous) BEGIN
        READ_SHORT (cur_meminfo_ofs + 0x02) num_memorizable
        SET step = num_spells / num_memorizable
      END ELSE BEGIN
        SET step = 1
      END

      FOR (j = 0; j < num_spells; j += step) BEGIN
        SET cur_memspell_ofs = ofs_memspells + (idx_spells + j) * memspell_size
        READ_ASCII cur_memspell_ofs resref (8) NULL
        PATCH_IF (NOT ~%resref%~ STR_EQ ~~) BEGIN
          SPRINT $memorized_spells(~%memorized_spells%~) ~%resref%~
          SET memorized_spells += 1
        END
      END
    END
  END
END


/**
 * Assigns a set of known and/or memorized spells to the current CRE.
 *
 * INT_VAR remove_priest    Indicates whether existing priest/druid spells should be removed. (Default: 1)
 * INT_VAR remove_wizard    Indicates whether existing wizard spells should be removed. (Default: 1)
 * INT_VAR remove_innate    Indicates whether existing innate abilities should be removed. (Default: 0)
 * STR_VAR known_spells_0, known_spells_1, ...
 *                          Individual spell entries to add to the "Known spells" list. Spell can be defined as SPL resref,
 *                          symbolic name, or numeric SPELL.IDS value.
 * STR_VAR memorized_spells_0, memorized_spells_1, ...
 *                          Indivual spell entries to add to the "Memorized spells" section. Each definition adds a single
 *                          instance to the "Memorized spells" section. Spell can be defined as SPL resref, symbolic name,
 *                          or numeric SPELL.IDS value.
 *                          Note: Spells for the Sorcerer and Shaman classes are memorized automatically according to the
 *                                known spells list and current CRE levels.
 * RET success              Returns 1 if the operation was successful, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#add_spells
INT_VAR
  remove_priest = 1
  remove_wizard = 1
  remove_innate = 0
STR_VAR
  // known_spells_0 = ~SPPR101~
  // known_spells_1 = ~SPPR102~
  // known_spells_2 = ...
  // memorized_spells_0 = ~SPPR101~
  // memorized_spells_1 = ~SPPR101~
  // memorized_spells_2 = ~SPPR102~
  // memorized_spells_3 = ...
RET
  success
BEGIN
  READ_ASCII 0 sig (8)
  SET success = ~%sig%~ STR_EQ ~CRE V1.0~
  PATCH_IF (NOT success) BEGIN
    PATCH_WARN ~WARNING: Not a CRE file.~
  END

  PATCH_IF (success) BEGIN
    // removing memorized and known spells (priest, wizard, innate)
    SET $spell_types(~0~) = remove_priest
    SET $spell_types(~1~) = remove_wizard
    SET $spell_types(~2~) = remove_innate
    READ_LONG 0x2a0 ofs_known
    READ_LONG 0x2a4 num_known
    FOR (i = num_known - 1; i >= 0; --i) BEGIN
      PATCH_IF (i < num_known) BEGIN
        SET ofs = ofs_known + i * 12
        READ_SHORT (ofs + 0x0a) type
        PATCH_IF (VARIABLE_IS_SET $spell_types(~%type%~) && $spell_types(~%type%~) != 0) BEGIN
          READ_ASCII ofs_known resref (8) NULL
          LPF a7#remove_memorized_spell STR_VAR resref END
          LPF a7#remove_known_spell STR_VAR resref END
          READ_LONG 0x2a0 ofs_known
          READ_LONG 0x2a4 num_known
        END
      END
    END
  END

  // collecting CRE attributes
  PATCH_IF (success) BEGIN
    // CRE class, kit, alignment, and class levels
    READ_BYTE 0x273 class
    SET is_shaman = (class == IDS_OF_SYMBOL(~class~ ~SHAMAN~))
    SET is_sorcerer = (class == IDS_OF_SYMBOL(~class~ ~SORCERER~))
    READ_BYTE 0x27b alignment
    SET kit = ((SHORT_AT 0x244) << 16) | (SHORT_AT 0x246)
    LPF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    FOR (i = 1; i <= 3; ++i) BEGIN
      SET EVAL ~level%i%~ = (EVAL ~class%i%~ > 0) ? BYTE_AT (0x233 + i) : 0
    END

    // character wisdom
    READ_BYTE 0x23b wis

    // "original class" flags for dualclass characters
    SET status = (LONG_AT 0x10) & (BIT3 | BIT4 | BIT5 | BIT6 | BIT7 | BIT8)
    PATCH_MATCH status WITH
      BIT3 BEGIN SET original_class = IDS_OF_SYMBOL(~class~ ~FIGHTER~) END
      BIT4 BEGIN SET original_class = IDS_OF_SYMBOL(~class~ ~MAGE~) END
      BIT5 BEGIN SET original_class = IDS_OF_SYMBOL(~class~ ~CLERIC~) END
      BIT6 BEGIN SET original_class = IDS_OF_SYMBOL(~class~ ~THIEF~) END
      BIT7 BEGIN SET original_class = IDS_OF_SYMBOL(~class~ ~DRUID~) END
      BIT8 BEGIN SET original_class = IDS_OF_SYMBOL(~class~ ~RANGER~) END
      DEFAULT SET original_class = 0
    END

    // getting wizard and priest spell slots for all levels
    LPF a7#calculate_spell_slots
      INT_VAR class kit level1 level2 level3 original_class wis
      RET success
      RET_ARRAY slots_priest_memorize slots_wizard_memorize slots_spells_known
    END
    PATCH_IF (NOT success) BEGIN
      PATCH_WARN ~WARNING: Unable to calculate spell slots~
    END
  END

  PATCH_IF (success) BEGIN
    // counting available known spells
    FOR (num_known_spells = 0; VARIABLE_IS_SET $known_spells(~%num_known_spells%~); ++num_known_spells) BEGIN END

    // adding new known spells according to the "known_spells" array
    FOR (idx = num_known_spells - 1; idx >= 0; --idx) BEGIN
      SPRINT entry $known_spells(~%idx%~)
      // determining SPL resref
      LPF a7#resolve_spell_resref STR_VAR spell = EVAL ~%entry%~ RET spl_resref = resref END

      // applying known spell if compatible
      LPF a7#get_spell_info STR_VAR resref = EVAL ~%spl_resref%~ RET spell_type school secondary level flags exclusion END
      PATCH_IF (spell_type == 0 && $slots_priest_memorize(~%level%~) > 0 && $slots_spells_known(~%level%~) >= 0) BEGIN
        // adding known priest spell
        LPF a7#is_spell_usable INT_VAR class kit alignment spell_type exclusion RET usable END
        PATCH_IF (usable) BEGIN
          SET spell_level = level - 1
          LPF a7#add_known_spell INT_VAR level = spell_level insert_point = 0 STR_VAR type = ~priest~ resref = EVAL ~%spl_resref%~ END
          SET $known_spell_added(~%spl_resref%~) = 1
          PATCH_IF (is_shaman && $slots_spells_known(~%level%~) > 0) BEGIN
            // auto-memorizing for Shamans
            SET num_memorize = $slots_priest_memorize(~%level%~)
            SET $slots_spells_known(~%level%~) -= 1
            LPF a7#add_memorized_spell INT_VAR level = spell_level count = num_memorize insert_point = 0 STR_VAR type = ~priest~ resref = EVAL ~%spl_resref%~ END
          END
        END
      END ELSE PATCH_IF (spell_type == 1 && $slots_spells_known(~%level%~) >= 0) BEGIN
        // adding known wizard spell
        LPF a7#is_spell_usable INT_VAR class kit alignment spell_type exclusion RET usable END
        PATCH_IF (usable) BEGIN
          SET spell_level = level - 1
          LPF a7#add_known_spell INT_VAR level = spell_level insert_point = 0 STR_VAR type = ~wizard~ resref = EVAL ~%spl_resref%~ END
          SET $known_spell_added(~%spl_resref%~) = 1
          PATCH_IF (is_sorcerer && $slots_spells_known(~%level%~) > 0) BEGIN
            // auto-memorizing for Sorcerers
            SET num_memorize = $slots_wizard_memorize(~%level%~)
            SET $slots_spells_known(~%level%~) -= 1
            LPF a7#add_memorized_spell INT_VAR level = spell_level count = num_memorize insert_point = 0 STR_VAR type = ~wizard~ resref = EVAL ~%spl_resref%~ END
          END
        END
      END ELSE PATCH_IF (spell_type == 2) BEGIN
        // no extra checks for innate abilities
        LPF a7#add_known_spell INT_VAR level = 0 insert_point = 0 STR_VAR type = ~innate~ resref = EVAL ~%spl_resref%~ END
        SET $known_spell_added(~%spl_resref%~) = 1
      END
    END

    // applying memorized spells
    PATCH_IF (NOT is_shaman && NOT is_sorcerer) BEGIN
      // counting available memorized spells
      FOR (num_memorized_spells = 0; VARIABLE_IS_SET $memorized_spells(~%num_memorized_spells%~); ++num_memorized_spells) BEGIN END

      FOR (idx = 0; idx < num_memorized_spells; ++idx) BEGIN
        SPRINT entry $memorized_spells(~%idx%~)
        // determining SPL resref
        LPF a7#resolve_spell_resref STR_VAR spell = EVAL ~%entry%~ RET spl_resref = resref END

        LPF a7#get_spell_info STR_VAR resref = EVAL ~%spl_resref%~ RET spell_type school secondary level flags exclusion END
        SET num_slots = spell_type == 0 ? $slots_priest_memorize(~%level%~) : (spell_type == 1) ? $slots_wizard_memorize(~%level%~) : 32768
        SET is_known = VARIABLE_IS_SET $known_spell_added(~%spl_resref%~) ? 1 : 0
        PATCH_IF (spell_type == 0 && $slots_priest_memorize(~%level%~) > 0 && VARIABLE_IS_SET $known_spell_added(~%spl_resref%~)) BEGIN
          // memorizing priest spell
          SET num_memorize = VARIABLE_IS_SET $slots_priest_available(~%level%~) ? $slots_priest_available(~%level%~) : $slots_priest_memorize(~%level%~)
          PATCH_IF (num_memorize > 0) BEGIN
            SET spell_level = level - 1
            LPF a7#add_memorized_spell INT_VAR level = spell_level insert_point = "-1" STR_VAR type = ~priest~ resref = EVAL ~%spl_resref%~ END
            SET $slots_priest_available(~%level%~) = num_memorize - 1
          END
        END ELSE PATCH_IF (spell_type == 1 && $slots_wizard_memorize(~%level%~) > 0 && VARIABLE_IS_SET $known_spell_added(~%spl_resref%~)) BEGIN
          // memorizing wizard spell
          SET num_memorize = VARIABLE_IS_SET $slots_wizard_available(~%level%~) ? $slots_wizard_available(~%level%~) : $slots_wizard_memorize(~%level%~)
          PATCH_IF (num_memorize > 0) BEGIN
            SET spell_level = level - 1
            LPF a7#add_memorized_spell INT_VAR level = spell_level insert_point = "-1" STR_VAR type = ~wizard~ resref = EVAL ~%spl_resref%~ END
            SET $slots_wizard_available(~%level%~) = num_memorize - 1
          END
        END ELSE PATCH_IF (spell_type == 2) BEGIN
          // memorizing innate ability
          LPF a7#add_memorized_spell INT_VAR level = spell_level count = num_memorize insert_point = "-1" STR_VAR type = ~innate~ resref = EVAL ~%spl_resref%~ END
        END
      END
    END
  END
END


/**
 * Performs a check on equipped items whether they are usable by the current CRE resource.
 *
 * INT_VAR move_to_inventory  Indicates whether incompatible items should be moved to the inventory if possible. (Default: 1)
 * INT_VAR remove_item        Indicates whether items should be removed from the CRE if no other options are available.
 *                            If "move_to_inventory" is enabled then removal is only considered if the item in question cannot
 *                            be moved to the inventory. (Default: 1)
 * INT_VAR force_move         Indicates whether items regardless of flags will be moved or removed. (Default: 0)
 */
DEFINE_PATCH_FUNCTION a7#validate_equipped_items
INT_VAR
  move_to_inventory = 1
  remove_item = 1
  force_move = 0
BEGIN
  // mapping item list
  READ_LONG 0x2bc ofs_items
  READ_LONG 0x2c0 num_items
  FOR (i = 0; i < num_items; ++i) BEGIN
    SET cur_ofs = ofs_items + i * 20
    SET undroppable = NOT force_move && (BIT3 & LONG_AT (cur_ofs + 0x10)) != 0
    PATCH_IF (undroppable) BEGIN
      SPRINT resref ~~
    END ELSE BEGIN
      READ_ASCII cur_ofs resref (8) NULL
    END
    SPRINT $items(~%i%~) ~%resref%~
  END

  // checking equipped items
  SET remove_items = 0
  READ_LONG 0x2b8 ofs_slots
  FOR (eq_slot = 0; eq_slot < 20; ++eq_slot) BEGIN
    SET ofs_eq_slot = ofs_slots + eq_slot * 2
    READ_SSHORT ofs_eq_slot eq_value
    PATCH_IF (eq_value >= 0 && eq_value < num_items) BEGIN
      SPRINT item_resref $items(~%eq_value%~)
      PATCH_IF (NOT ~%item_resref%~ STR_EQ ~~) BEGIN
        LPF a7#is_item_usable STR_VAR item_resref RET usable END
        PATCH_IF (NOT usable) BEGIN
          PATCH_IF (move_to_inventory) BEGIN
            // try moving item to inventory
            SET moved = 0
            FOR (inv_slot = 21; inv_slot < 37; ++inv_slot) BEGIN
              SET ofs_inv_slot = ofs_slots + inv_slot * 2
              READ_SSHORT ofs_inv_slot inv_value
              PATCH_IF (inv_value < 0) BEGIN
                // empty inventory slot found: move item
                WRITE_SHORT ofs_inv_slot eq_value
                WRITE_SHORT ofs_eq_slot "-1"
                SET moved = 1
                SET inv_slot = 37
              END
            END

            PATCH_IF (remove_item && NOT moved) BEGIN
              // mark item for complete removal
              SPRINT $remove_items(~%remove_items%~) ~%item_resref%~
              SET remove_items += 1
            END
          END ELSE BEGIN
            // remove item directly
            SPRINT $remove_items(~%remove_items%~) ~%item_resref%~
            SET remove_items += 1
          END
        END
      END
    END
  END

  // removing marked items
  FOR (i = 0; i < remove_items; ++i) BEGIN
    SPRINT resref $remove_items(~%i%~)
    REMOVE_CRE_ITEM ~%resref%~
  END
END


/**
 * Returns whether the specified item is usable by the current CRE resource.
 *
 * STR_VAR item_resref  Resref of the ITM resource to check.
 * RET usable           Returns 1 if the item is usable, 0 otherwise.
 */
DEFINE_PATCH_FUNCTION a7#is_item_usable
STR_VAR
  item_resref = ~~
RET
  usable
BEGIN
  SET usable = NOT ~%item_resref%~ STR_EQ ~~ && FILE_EXISTS_IN_GAME ~%item_resref%.ITM~
  PATCH_IF (NOT usable) BEGIN
    PATCH_WARN ~WARNING: Invalid item specified: %item_resref%.ITM~
  END

  PATCH_IF (usable) BEGIN
    // getting relevant CRE attributes
    SET $attribute(~STR~) = BYTE_AT 0x238
    SET $attribute(~STREXTRA~) = BYTE_AT 0x239
    PATCH_IF ($attribute(~STR~) != 18) BEGIN SET $attribute(~STREXTRA~) = 0 END
    SET $attribute(~INT~) = BYTE_AT 0x23a
    SET $attribute(~WIS~) = BYTE_AT 0x23b
    SET $attribute(~DEX~) = BYTE_AT 0x23c
    SET $attribute(~CON~) = BYTE_AT 0x23d
    SET $attribute(~CHR~) = BYTE_AT 0x23e
    SET $ids_value(~2~) = BYTE_AT 0x270 // EA
    SET $ids_value(~3~) = BYTE_AT 0x271 // GENERAL
    SET $ids_value(~4~) = BYTE_AT 0x272 // RACE
    SET $ids_value(~5~) = BYTE_AT 0x273 // CLASS
    SET $ids_value(~6~) = BYTE_AT 0x274 // SPECIFIC
    SET $ids_value(~7~) = BYTE_AT 0x275 // GENDER
    SET $ids_value(~8~) = BYTE_AT 0x27b // ALIGNMEN
    SET $ids_value(~9~) = ((SHORT_AT 0x244) << 16) | (SHORT_AT 0x246) // KIT
    SET $ids_value(~10~) = LONG_AT NAME1 // Actor's name
    READ_ASCII 0x280 $ids_value(~11~) (32) NULL // Actor's script name

    // calculating average class level and fixing "trueclass" kit
    LPF a7#get_base_classes INT_VAR class = $ids_value(~5~) RET class1 class2 class3 END
    SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1
    SET levels_avg = 0
    SET is_mage = 0
    FOR (i = 1; i <= num_classes; ++i) BEGIN
      SET levels_avg += BYTE_AT (0x233 + i)
      SET cur_class = EVAL ~class%i%~
      SET is_mage = is_mage || (cur_class == IDS_OF_SYMBOL(~class~ ~MAGE~))
    END
    SET round_up = (levels_avg MODULO num_classes) != 0
    SET levels_avg = levels_avg / num_classes + round_up
    PATCH_IF (NOT is_mage && $ids_value(~9~) == 0x4000) BEGIN
      // solve ambiguity with Generalist Mage kit
      SET $ids_value(~9~) = 0
    END
    LPF a7#get_kit_info INT_VAR kit = $ids_value(~9~) RET kit_label kit_class kit_unusability END

    INNER_ACTION BEGIN
      // general unusability flags, defined as IDS:LABEL
      ACTION_DEFINE_ARRAY unusable_general_array BEGIN
        // bits 0..7
        ~ALIGN:MASK_CHAOTIC~ ~ALIGN:MASK_EVIL~ ~ALIGN:MASK_GOOD~ ~ALIGN:MASK_GENEUTRAL~ ~ALIGN:MASK_LAWFUL~ ~ALIGN:MASK_LCNEUTRAL~ ~CLASS:BARD~ ~CLASS:CLERIC~
        // bits 8..15
        ~CLASS:CLERIC_MAGE~ ~CLASS:CLERIC_THIEF~ ~CLASS:CLERIC_RANGER~ ~CLASS:FIGHTER~ ~CLASS:FIGHTER_DRUID~ ~CLASS:FIGHTER_MAGE~ ~CLASS:FIGHTER_CLERIC~ ~CLASS:FIGHTER_MAGE_CLERIC~
        // bits 16..23
        ~CLASS:FIGHTER_MAGE_THIEF~ ~CLASS:FIGHTER_THIEF~ ~CLASS:MAGE~ ~CLASS:MAGE_THIEF~ ~CLASS:PALADIN~ ~CLASS:RANGER~ ~CLASS:THIEF~ ~RACE:ELF~
        // bits 24..31
        ~RACE:DWARF~ ~RACE:HALF_ELF~ ~RACE:HALFLING~ ~RACE:HUMAN~ ~RACE:GNOME~ ~CLASS:MONK~ ~CLASS:DRUID~ ~RACE:HALFORC~
      END

      // getting relevant item properties
      SILENT
      COPY_EXISTING ~%item_resref%.itm~ ~override~
        // general usability
        READ_LONG 0x1e unusable_general
        FOR (i = 0; usable && i < 32; ++i) BEGIN
          SET bit = (unusable_general >> i) & 1
          PATCH_IF (bit) BEGIN
            SPRINT entry $unusable_general_array(~%i%~)
            INNER_PATCH ~%entry%~ BEGIN
              SET idx = 0
              REPLACE_EVALUATE ~[^:]+~ BEGIN
                SPRINT $split(~%idx%~) ~%MATCH0%~
                SET idx += 1
              END ~%MATCH0%~
            END
            PATCH_IF (idx >= 2) BEGIN
              SPRINT ids_resref $split(~0~)
              SPRINT ids_label $split(~1~)
              SET id = IDS_OF_SYMBOL(~%ids_resref%~ ~%ids_label%~)
              PATCH_IF ($split(~0~) STR_EQ ~ALIGN~) BEGIN
                SET mask = (id & 3) != 0 ? 0x03 : 0x30
                SET usable = usable && ($ids_value(~8~) & mask) != id
              END ELSE PATCH_IF ($split(~0~) STR_EQ ~CLASS~) BEGIN
                SET usable = usable && $ids_value(~5~) != id
              END ELSE PATCH_IF ($split(~0~) STR_EQ ~RACE~) BEGIN
                SET usable = usable && $ids_value(~4~) != id
              END
            END
          END
        END

        // kit usability
        SET unusable_kits = ((BYTE_AT 0x29) << 24) | ((BYTE_AT 0x2b) << 16) | ((BYTE_AT 0x2d) << 8) | (BYTE_AT 0x2f)
        FOR (i = 0; usable && i < 32; ++i) BEGIN
          SET mask = unusable_kits & (1 << i)
          PATCH_IF (mask != 0) BEGIN
            SET usable = usable && ((kit_unusability & mask) == 0)
          END
        END

        // misc. attributes
        PATCH_IF (usable) BEGIN
          READ_SHORT 0x24 min_level
          SET usable = usable && levels_avg >= min_level

          SET $min_attribute(~STR~) = BYTE_AT 0x26
          SET $min_attribute(~STREXTRA~) = BYTE_AT 0x28
          PATCH_IF ($min_attribute(~STR~) != 18) BEGIN SET $min_attribute(~STREXTRA~) = 0 END
          SET $min_attribute(~INT~) = BYTE_AT 0x2a
          SET $min_attribute(~DEX~) = BYTE_AT 0x2c
          SET $min_attribute(~WIS~) = BYTE_AT 0x2e
          SET $min_attribute(~CON~) = BYTE_AT 0x30
          SET $min_attribute(~CHR~) = BYTE_AT 0x32
          PATCH_FOR_EACH key IN ~STR~ ~STREXTRA~ ~INT~ ~DEX~ ~WIS~ ~CON~ ~CHR~ BEGIN
            SET usable = usable && $attribute(~%key%~) >= $min_attribute(~%key%~)
          END
        END

        // usability opcode 319 (Restrict item)
        PATCH_IF (usable) BEGIN
          READ_LONG 0x6a ofs_effects
          READ_SHORT 0x6e idx_effects
          READ_SHORT 0x70 num_effects
          FOR (i = 0; usable && i < num_effects; ++i) BEGIN
            SET ofs = ofs_effects + (idx_effects + i) * 48
            READ_SHORT ofs opcode
            PATCH_IF (opcode == 319) BEGIN  // Restrict item
              READ_BYTE (ofs + 0x03) mode
              READ_LONG (ofs + 0x08) ids_target
              PATCH_IF (VARIABLE_IS_SET $ids_value(~%ids_target%~)) BEGIN
                PATCH_IF (ids_target == 11) BEGIN // Actor's script name
                  READ_ASCII (ofs + 0x14) ids_value (8) NULL
                  SET ids_match = $ids_value(~%ids_target%~) STR_EQ ~%ids_value%~
                END ELSE BEGIN
                  READ_LONG (ofs + 0x04) ids_value
                  SET ids_match = $ids_value(~%ids_target%~) == ids_value
                END

                // evaluating parameters
                PATCH_IF (mode == 0) BEGIN  // cumulative unusability
                  SET usable = usable && NOT ids_match
                END ELSE BEGIN  // exclusive usability
                  SET usable = ids_match
                END
              END
            END
          END
        END
      BUT_ONLY
      VERBOSE
    END
  END
END


/**
 * Returns the hit points value based on the specified parameters.
 *
 * INT_VAR class          Numeric class value (CLASS.IDS).
 * INT_VAR kit            Numeric kit value (KIT.IDS).
 * INT_VAR level1         Level of the first base class.
 * INT_VAR level2         Level of the second base class for dual- or multi-classes. (Default: 0)
 * INT_VAR level3         Level of the third base class for multi-classes. (Default: 0)
 * INT_VAR original_class For dual-class characters only: Specifies the numeric value of the original
 *                        class (CLASS.IDS). (Default: 0)
 * INT_VAR max_hp         Specifies whether the max. HP per level should be calculated. (Default: 0)
 * RET success            Returns 1 if the operation completed successfully, 0 otherwise.
 * RET hp                 Calculated hit points value.
 */
DEFINE_DIMORPHIC_FUNCTION a7#calculate_hitpoints
INT_VAR
  class = 0
  kit = 0
  level1 = 0
  level2 = 0
  level3 = 0
  original_class = 0
  max_hp = 0
RET
  success
  hp
BEGIN
  OUTER_SET hp = 0
  OUTER_SET success = (class > 0 && class < 22)
  ACTION_IF (NOT success) BEGIN
    WARN ~WARNING: Invalid class: %class%~
  END


  ACTION_IF (success) BEGIN
    // initializing kit if defined
    LAF a7#get_kit_info INT_VAR kit RET kit_label kit_class END

    // evaluating original class if defined
    ACTION_IF (original_class != 0) BEGIN
      OUTER_SET value = original_class
      LAF a7#evaluate_original_class INT_VAR class original_class RET original_class END
      ACTION_IF (original_class == 0) BEGIN
        // not a critical issue
        WARN ~WARNING: Ignoring unsupported or unused "original_class" value: %value%~
      END
    END

    // initializing lookup map "hpclass" with "class/kit label" => "hp table resref" entries
    SILENT
    COPY_EXISTING ~hpclass.2da~ ~override~
      READ_2DA_ENTRIES_NOW hpclass_table 1
      SPRINT hpclass_def $hpclass_table(~1~ ~0~)
      FOR (row = 3; row < hpclass_table; ++row) BEGIN
        SPRINT key $hpclass_table(~%row%~ ~0~)
        SPRINT value $hpclass_table(~%row%~ ~1~)
        SPRINT $hpclass(~%key%~) ~%value%~
      END
    BUT_ONLY
    VERBOSE

    // calculating hit points
    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    ACTION_IF (original_class == 0) BEGIN
      OUTER_SET num_classes_active = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1
    END ELSE BEGIN
      OUTER_SET num_classes_active = 1
    END
    OUTER_FOR (cls_idx = 1; cls_idx <= 3; ++cls_idx) BEGIN
      OUTER_SET class = EVAL ~class%cls_idx%~
      OUTER_SET level = EVAL ~level%cls_idx%~
      ACTION_IF (class > 0) BEGIN
        OUTER_SPRINT resref ~~
        ACTION_IF (kit_class == class) BEGIN
          // try kit table first
          ACTION_IF (VARIABLE_IS_SET $hpclass(~%kit_label%~)) BEGIN
            OUTER_SPRINT resref $hpclass(~%kit_label%~)
          END
        END

        ACTION_IF (~%resref%~ STR_EQ ~~ || NOT FILE_EXISTS_IN_GAME ~%resref%.2DA~) BEGIN
          // falling back to class table
          OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ class END
          ACTION_IF (VARIABLE_IS_SET $hpclass(~%class_label%~)) BEGIN
            OUTER_SPRINT resref $hpclass(~%class_label%~)
          END
        END

        ACTION_IF (~%resref%~ STR_EQ ~~ || NOT FILE_EXISTS_IN_GAME ~%resref%.2DA~) BEGIN
          // falling back to default table
          OUTER_SPRINT resref ~%hpclass_def%~
          WARN ~WARNING: HP table not found for class %class%. Using default table "%resref%".~
        END

        // caching hp table
        ACTION_IF (NOT VARIABLE_IS_SET EVAL ~%resref%_table~) BEGIN
          SILENT
          COPY_EXISTING ~%resref%.2DA~ ~override~
            READ_2DA_ENTRIES_NOW ~%resref%_table~ 1
          BUT_ONLY
          VERBOSE
        END

        // counting hitpoints
        OUTER_SET min_level = 1
        OUTER_SET max_level = level

        // consider dualclassing
        ACTION_IF (original_class != 0) BEGIN
          OUTER_FOR (i = 1; i <= 3; ++i) BEGIN
            OUTER_SET c = EVAL ~class%i%~
            ACTION_IF (c == original_class && c != class) BEGIN
              OUTER_SET l = EVAL ~level%i%~
              ACTION_IF (l > 0) BEGIN
                OUTER_SET min_level = l + 1
              END
            END
          END
        END

        OUTER_SET hp_level = 0
        OUTER_FOR (lvl = min_level; lvl <= max_level; ++lvl) BEGIN
          OUTER_SET row = 2 + lvl
          ACTION_IF (row < EVAL ~%resref%_table~) BEGIN
            OUTER_SET sides = $EVAL ~%resref%_table~(~%row%~ ~1~)
            OUTER_SET rolls = $EVAL ~%resref%_table~(~%row%~ ~2~)
            OUTER_SET mod = $EVAL ~%resref%_table~(~%row%~ ~3~)
            ACTION_IF (max_hp) BEGIN
              OUTER_SET hp_level = rolls * sides
            END ELSE BEGIN
              OUTER_SET hp_level = rolls * RANDOM(1 sides)
            END
            OUTER_SET hp_level += mod
            OUTER_SET hp_level /= num_classes_active
            OUTER_SET hp_level = (hp_level < 1) ? 1 : hp_level
          END
          OUTER_SET hp += hp_level
        END
      END
    END
  END
END


/**
 * Returns the effective AC and specific AC modifiers based on the specified parameters.
 *
 * INT_VAR class      Numeric class value (CLASS.IDS).
 * INT_VAR kit        Numeric kit value (KIT.IDS).
 * INT_VAR level1     Level of the first base class.
 * INT_VAR level2     Level of the second base class for dual- or multi-classes. (Default: 0)
 * INT_VAR level3     Level of the third base class for multi-classes. (Default: 0)
 * RET success        Returns 1 if the operation completed successfully, 0 otherwise.
 * RET ac_base        Calculated effective AC.
 * RET ac_crushing    Calculated Crushing AC modifier.
 * RET ac_missile     Calculated Missile AC modifier.
 * RET ac_piercing    Calculated Piercing AC modifier.
 * RET ac_slashing    Calculated Slashing AC modifier.
 */
DEFINE_DIMORPHIC_FUNCTION a7#calculate_ac
INT_VAR
  class = 0
  kit = 0
  level1 = 0
  level2 = 0
  level3 = 0
RET
  success
  ac_base
  ac_crushing
  ac_missile
  ac_piercing
  ac_slashing
BEGIN
  OUTER_SET success = 1
  OUTER_SET ac_base = 10
  OUTER_SET ac_crushing = 0
  OUTER_SET ac_missile = 0
  OUTER_SET ac_piercing = 0
  OUTER_SET ac_slashing = 0

  OUTER_SET success = (class > 0 && class < 22)
  ACTION_IF (NOT success) BEGIN
    WARN ~WARNING: Invalid class: %class%~
  END

  ACTION_IF (success) BEGIN
    LAF a7#get_clab INT_VAR class kit RET clab_resref1 clab_resref2 clab_resref3 is_multiclass_kit END
    OUTER_SET cur_ac_base = 10
    // searching for AC-altering spell effects
    OUTER_FOR (idx = 1; idx <= 3; ++idx) BEGIN
      OUTER_SET cur_level = EVAL ~level%idx%~
      OUTER_SPRINT cur_clab_resref EVAL ~%clab_resref%idx%%~
      SILENT
      COPY_EXISTING ~%cur_clab_resref%.2DA~ ~override~
        READ_2DA_ENTRIES_NOW ~%cur_clab_resref%_table~ 1
        // scanning CLAB for AP_ spell entries
        FOR (row = 3; row < EVAL ~%cur_clab_resref%_table~; ++row) BEGIN
          FOR (col = 1; col <= cur_level && VARIABLE_IS_SET $EVAL ~%cur_clab_resref%_table~(~%row%~ ~%col%~); ++col) BEGIN
            SPRINT entry $EVAL ~%cur_clab_resref%_table~(~%row%~ ~%col%~)
            PATCH_IF (~%entry%~ STRING_MATCHES_REGEXP ~^AP_.*~ == 0) BEGIN
              INNER_PATCH_SAVE spl_resref ~%entry%~ BEGIN REPLACE_TEXTUALLY ~^AP_~ ~~ END
              PATCH_IF (FILE_EXISTS_IN_GAME ~%spl_resref%.SPL~) BEGIN
                INNER_ACTION BEGIN
                  // scanning spell resource
                  COPY_EXISTING ~%spl_resref%.SPL~ ~override~
                    READ_LONG 0x64 ofs_abils
                    READ_SHORT 0x68 num_abils
                    READ_LONG 0x6a ofs_effects
                    FOR (i = num_abils - 1; i >= 0; --i) BEGIN
                      SET ofs_abil = ofs_abils + i * 40
                      READ_SHORT (ofs_abil + 0x10) min_level
                      PATCH_IF (cur_level >= min_level) BEGIN
                        // scanning opcodes
                        READ_SHORT (ofs_abil + 0x1e) num_effects
                        READ_SHORT (ofs_abil + 0x20) idx_effects
                        FOR (j = 0; j < num_effects; ++j) BEGIN
                          SET ofs_effect = ofs_effects + (idx_effects + j) * 48
                          SET param1 = 0 SET param2 = 0 SET timing = 0
                          READ_SHORT ofs_effect opcode
                          PATCH_IF (opcode == 0) BEGIN  // AC bonus
                            // direct effect definition
                            READ_LONG (ofs_effect + 0x04) param1
                            READ_LONG (ofs_effect + 0x08) param2
                            READ_BYTE (ofs_effect + 0x0c) timing
                          END ELSE PATCH_IF (opcode == 177) BEGIN
                            // effect definition via EFF resource
                            READ_ASCII (ofs_effect + 0x14) eff_resref (8) NULL
                            PATCH_IF (FILE_EXISTS_IN_GAME ~%eff_resref%.EFF~) BEGIN
                              INNER_ACTION BEGIN
                                // scanning EFF resource
                                COPY_EXISTING ~%eff_resref%.EFF~ ~override~
                                  READ_LONG 0x10 opcode
                                  PATCH_IF (opcode == 0) BEGIN  // AC bonus
                                    READ_LONG (ofs_effect + 0x1c) param1
                                    READ_LONG (ofs_effect + 0x20) param2
                                    READ_LONG (ofs_effect + 0x0c) timing
                                  END
                                BUT_ONLY
                              END
                            END
                          END

                          // evaluating effect
                          PATCH_IF (opcode == 0 && (timing == 1 || timing == 9)) BEGIN
                            PATCH_MATCH param2 WITH
                              1 BEGIN SET ac_crushing -= param1 END
                              2 BEGIN SET ac_missile -= param1 END
                              4 BEGIN SET ac_piercing -= param1 END
                              8 BEGIN SET ac_slashing -= param1 END
                              16 BEGIN SET ac_base = param1 END
                              DEFAULT
                            END
                          END
                        END
                        SET i = "-1"
                      END
                    END
                  BUT_ONLY
                END
              END
            END
          END
        END
      BUT_ONLY IF_EXISTS
      VERBOSE
    END

    ACTION_IF (class == 20) BEGIN // MONK
      OUTER_SET ac_missile -= level1 / 3   // hardcoded by the engine
    END
  END
END


/**
 * Returns the THAC0 value based on the specified parameters.
 *
 * INT_VAR class          Numeric class value (CLASS.IDS).
 * INT_VAR kit            Numeric kit value (KIT.IDS).
 * INT_VAR level1         Level of the first base class.
 * INT_VAR level2         Level of the second base class for dual- or multi-classes. (Default: 0)
 * INT_VAR level3         Level of the third base class for multi-classes. (Default: 0)
 * RET success            Returns 1 if the operation completed successfully, 0 otherwise.
 * RET thac0              Calculated THAC0 value.
 */
DEFINE_DIMORPHIC_FUNCTION a7#calculate_thac0
INT_VAR
  class = 0
  kit = 0
  level1 = 0
  level2 = 0
  level3 = 0
RET
  success
  thac0
BEGIN
  OUTER_SET thac0 = 256
  OUTER_SET success = (class > 0 && class < 22)
  ACTION_IF (NOT success) BEGIN
    WARN ~WARNING: Invalid class: %class%~
  END

  ACTION_IF (success) BEGIN
    // initializing kit if defined
    LAF a7#get_kit_info INT_VAR kit RET kit_label kit_class END

    // initializing "clasthac" lookup map with "class/kit label" => bonus entries
    SILENT
    COPY_EXISTING ~clasthac.2da~ ~override~
      READ_2DA_ENTRIES_NOW clasthac_table 1
      PATCH_IF (clasthac_table > 3) BEGIN
        FOR (col = 0; VARIABLE_IS_SET $clasthac_table(~2~ ~%col%~); ++col) BEGIN
          SPRINT key $clasthac_table(~2~ ~%col%~)
          SET col2 = col + 1
          SPRINT value $clasthac_table(~3~ ~%col2%~)
          SET value = (IS_AN_INT ~value~) ? value : 0
          SET $clasthac(~%key%~) = value
        END
      END
    BUT_ONLY
    VERBOSE

    // initializing "thac0" lookup table
    SILENT
    COPY_EXISTING ~thac0.2da~ ~override~
      READ_2DA_ENTRIES_NOW thac0_table 1
      SET thac0_def = $thac0_table(~1~ ~0~)
      FOR (row = 3; row < thac0_table; ++row) BEGIN
        SPRINT key $thac0_table(~%row%~ ~0~)
        SET $thac0(~%key%~ ~0~) = thac0_def // default value
        FOR (col = 1; VARIABLE_IS_SET $thac0_table(~%row%~ ~%col%~); ++col) BEGIN
          SET $thac0(~%key%~ ~%col%~) = $thac0_table(~%row%~ ~%col%~)
        END
        SET $thac0(~%key%~) = col
      END
    BUT_ONLY
    VERBOSE

    // fetching thac0 bonus
    OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ class END
    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    OUTER_SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1
    ACTION_IF (kit_class == class1 && VARIABLE_IS_SET $clasthac(~%kit_label%~)) BEGIN
      OUTER_SET thac0_bonus = $clasthac(~%kit_label%~)
    END ELSE ACTION_IF (VARIABLE_IS_SET $clasthac(~%class_label%~)) BEGIN
      OUTER_SET thac0_bonus = $clasthac(~%class_label%~)
    END ELSE BEGIN
      OUTER_SET thac0_bonus = $clasthac(~%class_label%~)
    END

    // calculating effective thac0 value
    OUTER_FOR (cls_idx = 1; cls_idx <= 3; ++cls_idx) BEGIN
      OUTER_SET class = EVAL ~class%cls_idx%~
      OUTER_SET level = EVAL ~level%cls_idx%~
      ACTION_IF (class > 0) BEGIN
        OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ class END
        ACTION_IF (VARIABLE_IS_SET $thac0(~%class_label%~)) BEGIN
          OUTER_SET count = $thac0(~%class_label%~)
          OUTER_SET col = level >= count ? count - 1 : level
          OUTER_SET value = $thac0(~%class_label%~ ~%col%~)
          ACTION_IF (value < thac0) BEGIN
            OUTER_SET thac0 = value
          END
        END
      END
    END

    ACTION_IF (thac0 == 256) BEGIN
      OUTER_SET success = 0
      WARN ~WARNING: Unable to determine THAC0 value~
    END ELSE BEGIN
      // kit/class-specific bonus is added to the effective value
      OUTER_SET thac0 += thac0_bonus
    END
  END
END


/**
 * Returns the Lore value based on the specified parameters.
 *
 * INT_VAR class          Numeric class value (CLASS.IDS).
 * INT_VAR level1         Level of the first base class.
 * INT_VAR level2         Level of the second base class for dual- or multi-classes. (Default: 0)
 * INT_VAR level3         Level of the third base class for multi-classes. (Default: 0)
 * RET success            Returns 1 if the operation completed successfully, 0 otherwise.
 * RET lore               Calculated Lore value.
 */
DEFINE_DIMORPHIC_FUNCTION a7#calculate_lore
INT_VAR
  class = 0
  level1 = 0
  level2 = 0
  level3 = 0
RET
  success
  lore
BEGIN
  OUTER_SET lore = 0
  OUTER_SET success = (class > 0 && class < 22)
  ACTION_IF (NOT success) BEGIN
    WARN ~WARNING: Invalid class: %class%~
  END

  ACTION_IF (success) BEGIN
    // initializing Lore lookup map with "class label" => value entries
    SILENT
    COPY_EXISTING ~lore.2da~ ~override~
      READ_2DA_ENTRIES_NOW lore_table 1
      SET lore_def = $lore_table(~1~ ~0~)
      FOR (row = 3; row < lore_table; ++row) BEGIN
        SPRINT key $lore_table(~%row%~ ~0~)
        SET value = $lore_table(~%row%~ ~1~)
        SET $lore(~%key%~) = value
      END
    BUT_ONLY
    VERBOSE

    // calculating lore
    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    OUTER_SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1
    OUTER_FOR (cls_idx = 1; cls_idx <= 3; ++cls_idx) BEGIN
      OUTER_SET class = EVAL ~class%cls_idx%~
      OUTER_SET level = EVAL ~level%cls_idx%~
      ACTION_IF (class > 0) BEGIN
        OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ class END
        OUTER_SET lore_value = VARIABLE_IS_SET $lore(~%class_label%~) ? $lore(~%class_label%~) : lore_def
        OUTER_SET class_lore = level * lore_value
        OUTER_SET lore = (class_lore > lore) ? class_lore : lore
      END
    END

    // applying lore bonus
    OUTER_SET lore = (lore < 0) ? 0 : (lore > 255) ? 255 : lore   // value is bound to [0, 255]
  END
END


/**
 * Returns saving throw values based on the specified parameters.
 *
 * INT_VAR race     Numeric race value (RACE.IDS).
 * INT_VAR class    Numeric class value (CLASS.IDS).
 * INT_VAR con      Numeric constitution value of the character in the range [1, 25].
 * INT_VAR level1   Level of the first base class.
 * INT_VAR level2   Level of the second base class for dual- or multiclasses. (Default: 0)
 * INT_VAR level3   Level of the third base class for triple classes. (Default: 0)
 * RET success      Returns 1 if the operation completed successfully, 0 otherwise.
 * RET save_death   Save vs. death value.
 * RET save_wands   Save vs. wands value.
 * RET save_poly    Save vs. polymorph value.
 * RET save_breath  Save vs. breath value.
 * RET save_spell   Save vs. spell value.
 */
DEFINE_DIMORPHIC_FUNCTION a7#calculate_saving_throws
INT_VAR
  race = 0
  class = 0
  con = 0
  level1 = 0
  level2 = 0
  level3 = 0
RET
  success
  save_death
  save_wands
  save_poly
  save_breath
  save_spell
BEGIN
  // Saving throw calculation:
  // - Single-class:      Value from class table
  // - Dual-/Multi-class: Lowest value from all base class tables
  OUTER_SET success = (class > 0 && class < 22)
  ACTION_IF (NOT success) BEGIN
    WARN ~WARNING: Invalid class: %class%~
  END

  // clamping CON to [0, 25]
  OUTER_SET con = (con < 0) ? 0 : (con > 25) ? 25 : con

  ACTION_IF (success) BEGIN
    ACTION_DEFINE_ASSOCIATIVE_ARRAY save_vars BEGIN
      ~DEATH~ => ~save_death~
      ~WANDS~ => ~save_wands~
      ~POLY~ => ~save_poly~
      ~BREATH~ => ~save_breath~
      ~SPELL~ => ~save_spell~
    END
    ACTION_PHP_EACH save_vars AS _ => name BEGIN
      OUTER_SET EVAL ~%name%~ = 256
    END

    // initializing array with race-specific bonuses in "savebonus" map with "save_type" "con_value" => save_bonus entries
    ACTION_PHP_EACH save_vars AS key => _ BEGIN
      OUTER_FOR (i = 0; i <= 25; ++i) BEGIN
        OUTER_SET $savebonus(~%key%~ ~%i%~) = 0
      END
    END
    ACTION_IF (race == IDS_OF_SYMBOL(~race~ ~DWARF~) || race == IDS_OF_SYMBOL(~race~ ~HALFLING~)) BEGIN
      OUTER_SPRINT resref ~savecndh~
    END ELSE ACTION_IF (race == IDS_OF_SYMBOL(~race~ ~GNOME~)) BEGIN
      OUTER_SPRINT resref ~savecng~
    END ELSE BEGIN
      OUTER_SPRINT resref ~~
    END
    ACTION_IF (NOT ~%resref%~ STR_EQ ~~) BEGIN
      SILENT
      COPY_EXISTING ~%resref%.2da~ ~override~
        COUNT_2DA_COLS savebonus_cols
        READ_2DA_ENTRIES_NOW savebonus_table 1
        FOR (row = 3; row < savebonus_table; ++row) BEGIN
          SPRINT key $savebonus_table(~%row%~ ~0~)
          SET value = $savebonus_table(~1~ ~0~)
          SET $savebonus(~%key%~ ~0~) = value
          FOR (col = 1; col < 25; ++col) BEGIN
            PATCH_IF (VARIABLE_IS_SET $savebonus_table(~%row%~ ~%col%~)) BEGIN
              SET value = $savebonus_table(~%row%~ ~%col%~)
            END
            SET $savebonus(~%key%~ ~%col%~) = value
          END
        END
      BUT_ONLY
      VERBOSE
    END
  END

  ACTION_IF (success) BEGIN
    // processing saving throws
    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    ACTION_IF (class1 > 0) BEGIN
      OUTER_FOR (cls_idx = 1; cls_idx <= 3; ++cls_idx) BEGIN
        OUTER_SET class = EVAL ~class%cls_idx%~
        OUTER_SET level = EVAL ~level%cls_idx%~

        ACTION_IF (class > 0) BEGIN
          ACTION_IF (level < 1) BEGIN OUTER_SET level = 1 END

          // getting class category (for determining saving throw table)
          LAF a7#get_class_category INT_VAR class RET category END
          ACTION_MATCH category WITH
            1 BEGIN OUTER_SPRINT resref ~savewiz~ END
            2 BEGIN OUTER_SPRINT resref ~savewar~ END
            3 BEGIN OUTER_SPRINT resref ~saveprs~ END
            4 BEGIN OUTER_SPRINT resref ~saverog~ END
            5 BEGIN OUTER_SPRINT resref ~savemonk~ END
            DEFAULT WARN ~WARNING: Could not determine category for class %class%~
          END

          ACTION_IF (NOT ~%resref%~ STR_EQ ~~) BEGIN
            // caching saving throw table
            ACTION_IF (NOT VARIABLE_IS_SET EVAL ~%resref%_table~) BEGIN
              SILENT
              COPY_EXISTING ~%resref%.2da~ ~override~
                COUNT_2DA_COLS EVAL ~%resref%_cols~
                READ_2DA_ENTRIES_NOW ~%resref%_table~ 1
              BUT_ONLY
              VERBOSE
            END

            // calculating effective saves
            OUTER_SET col = level >= EVAL ~%resref%_cols~ ? EVAL ~%resref%_cols~ - 1 : level
            OUTER_FOR (row = 3; row < EVAL ~%resref%_table~; ++row) BEGIN
              OUTER_SPRINT key $EVAL ~%resref%_table~(~%row%~ ~0~)
              ACTION_IF (VARIABLE_IS_SET $save_vars(~%key%~) && VARIABLE_IS_SET $EVAL ~%resref%_table~(~%row%~ ~%col%~)) BEGIN
                OUTER_SPRINT save_var $save_vars(~%key%~)
                OUTER_SET EVAL ~%save_var%~ = $EVAL ~%resref%_table~(~%row%~ ~%col%~)
                ACTION_IF (VARIABLE_IS_SET $savebonus(~%key%~ ~%con%~)) BEGIN
                  // applying "shorty" bonus
                  OUTER_SET EVAL ~%save_var%~ -= $savebonus(~%key%~ ~%con%~)
                END
              END
            END
          END
        END
      END

      // validating results
      ACTION_PHP_EACH save_vars AS _ => name BEGIN
        ACTION_IF (success) BEGIN
          OUTER_SET value = EVAL ~%name%~
          ACTION_IF (value == 256) BEGIN
            OUTER_SET success = 0
            WARN ~WARNING: Unable to determine saving throw value for "%name%"~
          END
        END
      END
    END ELSE BEGIN
      OUTER_SET success = 0
      WARN ~WARNING: Invalid class value: %class%~
    END
  END
END


/**
 * Returns thieving skill values based on the specified parameters.
 *
 * INT_VAR race         Numeric race value (RACE.IDS).
 * INT_VAR class        Numeric class value (CLASS.IDS).
 * INT_VAR kit          Numeric kit value (KIT.IDS).
 * INT_VAR level1       Level of the first base class.
 * INT_VAR level2       Level of the second base class for dual- or multiclasses. (Default: 0)
 * INT_VAR level3       Level of the third base class for triple classes. (Default: 0)
 * RET success          Returns 1 if the operation completed successfully, 0 otherwise.
 * RET points_available Returns the number of available skill points that can be spent on thieving skills.
 *                      If this value is zero then the individual thieving skills returns calculated scores
 *                      (e.g. for bards, rangers or shamans) according to the specified parameters.
 *                      If this value is non-zero then the individual thieving skills return -1 for unavailable skills
 *                      and 0 or higher values for available skills.
 * RET pick_pockets     Returns the calculated Pick Pockets skill or availability (see "points_available").
 * RET open_locks       Returns the calculated Open Locks skill or availability (see "points_available").
 * RET find_traps       Returns the calculated Find Traps skill or availability (see "points_available").
 * RET move_silently    Returns the calculated Move Silently skill or availability (see "points_available").
 * RET hide_in_shadows  Returns the calculated Hide in Shadows skill or availability (see "points_available").
 * RET detect_illusion  Returns the calculated Detect Illusion skill or availability (see "points_available").
 * RET set_traps        Returns the calculated Set Traps skill or availability (see "points_available").
 */
DEFINE_DIMORPHIC_FUNCTION a7#calculate_thieving_skills
INT_VAR
  race = 0
  class = 0
  kit = 0
  level1 = 0
  level2 = 0
  level3 = 0
RET
  success
  points_available
  pick_pockets
  open_locks
  find_traps
  move_silently
  hide_in_shadows
  detect_illusion
  set_traps
BEGIN
  // BARD, RANGER, SHAMAN: points are calculated and auto-distributed
  // MONK and THIEF (single/multi): points are granted for manual distribution

  // Involved tables:
  // CLASISKL.2DA   // initial scores
  // SKILLBRD.2DA   // bard thieving scores per level
  // SKILLDEX.2DA   // dex-related bonus !!calculated dynamically!!
  // SKILLRAC.2DA   // initial thief skills per race  !!calculated dynamically!!
  // SKILLRNG.2DA   // ranger thieving scores per level (move silently also applies to hide in shadows)
  // SKILLSHM.2DA   // shaman thieving scores per level
  // THIEFSCL.2DA   // thieving skills percentage: determines how to translate available points into thieving scores (100 = 1 -> 1, 200 = 1 -> 2, ...)
  // THIEFSKL.2DA   // starting points and level points for distributing to thieving skills per class or kit

  OUTER_SET success = (class > 0 && class < 22)
  ACTION_IF (NOT success) BEGIN
    WARN ~WARNING: Invalid class: %class%~
  END

  ACTION_IF (success) BEGIN
    OUTER_SET success = (race > 0 && race < 256)
    ACTION_IF (NOT success) BEGIN
      WARN ~WARNING: Invalid race: %race%~
    END
  END

  ACTION_IF (success) BEGIN
    // initializing kit if defined
    LAF a7#get_kit_info INT_VAR kit RET kit_label kit_class END

    OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ class END

    // mapping and initializing return values
    OUTER_SET points_available = 0
    ACTION_DEFINE_ASSOCIATIVE_ARRAY skill_vars BEGIN
      ~PICK_POCKETS~    => ~pick_pockets~
      ~OPEN_LOCKS~      => ~open_locks~
      ~FIND_TRAPS~      => ~find_traps~
      ~MOVE_SILENTLY~   => ~move_silently~
      ~HIDE_IN_SHADOWS~ => ~hide_in_shadows~
      ~DETECT_ILLUSION~ => ~detect_illusion~
      ~SET_TRAPS~       => ~set_traps~
    END
    ACTION_PHP_EACH skill_vars AS _ => skill_var BEGIN
      OUTER_SET EVAL ~%skill_var%~ = "-1"
    END

    // getting multipliers for thieving skills in "percentages" array
    SILENT
    COPY_EXISTING ~thiefscl.2da~ ~override~
      PHP_EACH skill_vars AS label => _ BEGIN
        SET $percentages(~%label%~) = 0
      END

      PATCH_IF (NOT ~%kit_label%~ STR_EQ ~~ && INDEX_BUFFER(~\b%kit_label%\b~) > 0) BEGIN
        SPRINT header_title ~%kit_label%~
      END ELSE PATCH_IF (INDEX_BUFFER(~\b%class_label%\b~) > 0) BEGIN
        SPRINT header_title ~%class_label%~
      END ELSE BEGIN
        SPRINT header_title ~~
      END

      PATCH_IF (NOT ~%header_title%~ STR_EQ ~~) BEGIN
        READ_2DA_ENTRIES_NOW thiefscl_table 1
        SET found = 0
        FOR (header = 0; NOT found && VARIABLE_IS_SET $thiefscl_table(~2~ ~%header%~); ++header) BEGIN
          SPRINT label $thiefscl_table(~2~ ~%header%~)
          PATCH_IF (~%label%~ STR_EQ ~%header_title%~) BEGIN
            SET found = 1
            SET col = header + 1
            FOR (row = 3; row < thiefscl_table; ++row) BEGIN
              SPRINT key $thiefscl_table(~%row%~ ~0~)
              PATCH_IF (VARIABLE_IS_SET $skill_vars(~%key%~)) BEGIN
                SET value = $thiefscl_table(~%row%~ ~%col%~)
                SET $percentages(~%key%~) = value
                PATCH_IF (value > 0) BEGIN
                  SPRINT skill_var $skill_vars(~%key%~)
                  SET EVAL ~%skill_var%~ = 0
                END
              END
            END
          END
        END
      END
    BUT_ONLY
    VERBOSE

    // getting thieving points to distribute, per kit or class
    SILENT
    COPY_EXISTING ~thiefskl.2da~ ~override~
      PATCH_IF (NOT ~%kit_label%~ STR_EQ ~~ && INDEX_BUFFER(~\b%kit_label%\b~) > 0) BEGIN
        SPRINT header_title ~%kit_label%~
      END ELSE PATCH_IF (INDEX_BUFFER(~\b%class_label%\b~) > 0) BEGIN
        SPRINT header_title ~%class_label%~
      END ELSE BEGIN
        SPRINT header_title ~~
      END

      SET start_points = 0
      SET level_points = 0
      PATCH_IF (NOT ~%header_title%~ STR_EQ ~~) BEGIN
        READ_2DA_ENTRIES_NOW thiefskl_table 1
        FOR (row = 3; row < thiefskl_table; ++row) BEGIN
          SPRINT key $thiefskl_table(~%row%~ ~0~)
          PATCH_IF (~%key%~ STR_EQ ~%header_title%~) BEGIN
            SET start_points = $thiefskl_table(~%row%~ ~1~)
            SET level_points = $thiefskl_table(~%row%~ ~2~)
            SET row = thiefskl_table
          END
        END
      END
    BUT_ONLY
    VERBOSE

    // processing thieving skills
    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    OUTER_SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : (class1 > 0) ? 1 : 0
    ACTION_IF (num_classes > 0) BEGIN
      OUTER_FOR (cls_idx = 1; cls_idx <= num_classes; ++cls_idx) BEGIN
        OUTER_SET cur_level = EVAL ~level%cls_idx%~
        OUTER_SET cur_class = EVAL ~class%cls_idx%~
        OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ cur_class END
        ACTION_MATCH cur_class WITH
          5  BEGIN OUTER_SPRINT resref ~skillbrd~ END
          12 BEGIN OUTER_SPRINT resref ~skillrng~ END
          21 BEGIN OUTER_SPRINT resref ~skillshm~ END
          DEFAULT OUTER_SPRINT resref ~~
        END

        ACTION_IF (NOT ~%resref%~ STR_EQ ~~) BEGIN
          // auto-assigning skill points
          // distributing initial scores
          SILENT
          COPY_EXISTING ~clasiskl.2da~ ~override~
            PATCH_IF (NOT ~%kit_label%~ STR_EQ ~~ && INDEX_BUFFER(~\b%kit_label%\b~) > 0) BEGIN
              SPRINT header_title ~%kit_label%~
            END ELSE PATCH_IF (INDEX_BUFFER(~\b%class_label%\b~) > 0) BEGIN
              SPRINT header_title ~%class_label%~
            END ELSE BEGIN
              SPRINT header_title ~~
            END

            PATCH_IF (NOT ~%header_title%~ STR_EQ ~~) BEGIN
              READ_2DA_ENTRIES_NOW clasiskl_table 1
              SET found = 0
              FOR (header = 0; NOT found && VARIABLE_IS_SET $clasiskl_table(~2~ ~%header%~); ++header) BEGIN
                SPRINT label $clasiskl_table(~2~ ~%header%~)
                PATCH_IF (~%label%~ STR_EQ ~%header_title%~) BEGIN
                  SET found = 1
                  SET col = header + 1
                  FOR (row = 3; row < clasiskl_table; ++row) BEGIN
                    SPRINT key $clasiskl_table(~%row%~ ~0~)
                    PATCH_IF (VARIABLE_IS_SET $skill_vars(~%key%~)) BEGIN
                      SPRINT skill_var $skill_vars(~%key%~)
                      SET EVAL ~%skill_var%~ = $clasiskl_table(~%row%~ ~%col%~)
                    END
                  END
                END
              END
            END
          BUT_ONLY
          VERBOSE

          // auto-distributing according to table
          SILENT
          COPY_EXISTING ~%resref%.2da~ ~override~
            READ_2DA_ENTRIES_NOW skills_table 1
            FOR (header = 0; VARIABLE_IS_SET $skills_table(~2~ ~%header%~); ++header) BEGIN
              SPRINT key $skills_table(~2~ ~%header%~)
              PATCH_IF (VARIABLE_IS_SET $skill_vars(~%key%~)) BEGIN
                SPRINT skill_var $skill_vars(~%key%~)
                SET lvl = (cur_level < 1) ? 1 : (cur_level > skills_table - 3) ? skills_table - 3 : cur_level
                SET col = header + 1
                SET row = 2 + lvl
                PATCH_IF (row < skills_table) BEGIN
                  SET value = $skills_table(~%row%~ ~%col%~)
                  SET EVAL ~%skill_var%~ = value
                  PATCH_IF (~%key%~ STR_EQ ~MOVE_SILENTLY~) BEGIN
                    // "Move Silently" includes "Hide in Shadows"
                    SPRINT skill_var $skill_vars(~HIDE_IN_SHADOWS~)
                    SET EVAL ~%skill_var%~ = value
                  END
                END
              END
            END
          BUT_ONLY
          VERBOSE
        END ELSE ACTION_IF (cur_class == 4 || cur_class == 20) BEGIN
          // calculating available skill points
          ACTION_IF (cur_level > 0) BEGIN
            OUTER_SET points_available = start_points + (cur_level - 1) * level_points
          END
        END
      END

      // Applying skill multipliers
      ACTION_PHP_EACH skill_vars AS key => name BEGIN
        OUTER_SET value = EVAL ~%name%~
        ACTION_IF (value > 0 && VARIABLE_IS_SET $percentages(~%key%~)) BEGIN
          OUTER_SET percent = $percentages(~%key%~)
          OUTER_SET value = value * percent / 100
          OUTER_SET EVAL ~%name%~ = value
        END
      END
    END ELSE BEGIN
      OUTER_SET success = 0
      WARN ~WARNING: Invalid class value: %class%~
    END
  END
END


/**
 * Returns number of available proficiency points and an associative array of allowed weapon proficiencies and styles
 * with their max. number of points to assign, based on the specified parameters.
 *
 * INT_VAR class            Numeric class value (CLASS.IDS).
 * INT_VAR kit              Numeric kit value (KIT.IDS).
 * INT_VAR level1           Level of the first base class.
 * INT_VAR level2           Level of the second base class for dual- or multiclasses. (Default: 0)
 * INT_VAR level3           Level of the third base class for triple classes. (Default: 0)
 * INT_VAR original_class   For dual-class characters only: Specifies the numeric value of the original
 *                          class (CLASS.IDS). (Default: 0)
 * RET success              Returns 1 if the operation completed successfully, 0 otherwise.
 * RET points_available     Number of points that can be spent on weapon proficiencies and styles.
 * RET_ARRAY proficiencies  An associative array of "proficiency_id" => "max_points" entries for all proficiencies
 *                          defined in WEAPPROF.2DA.
 */
DEFINE_DIMORPHIC_FUNCTION a7#calculate_proficiencies
INT_VAR
  class = 0
  kit = 0
  level1 = 0
  level2 = 0
  level3 = 0
  original_class = 0
RET
  success
  points_available
RET_ARRAY
  proficiencies
BEGIN
  // Involved tables:
  // WEAPPROF.2DA   Max. points allowed per weapon proficiency and style for each class and kit
  // PROFS.2DA      How often points are granted to put into weapon proficiencies/styles
  // PROFSMAX.2DA   How many points can be assigned at specific levels (FIRST_LEVEL: # points at level 1, 3: # points at level 3, 6: # points at level 6, 9: # points at level 9, OTHER_LEVELS: # points at levels > 9)
  // Notes:
  // Dual-class: calculate for each class aspect like single-class
  // Preferences of multi-class aspects: WARRIOR > PRIEST > ROGUE > WIZARD

  OUTER_SET points_available = 0
  OUTER_SET success = (class > 0 && class < 22)
  ACTION_IF (NOT success) BEGIN
    WARN ~WARNING: Invalid class: %class%~
  END

  ACTION_IF (success) BEGIN
    // initializing kit if defined
    LAF a7#get_kit_info INT_VAR kit RET kit_label kit_class END

    OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ class END

    // evaluating original class if defined
    ACTION_IF (original_class != 0) BEGIN
      OUTER_SET value = original_class
      LAF a7#evaluate_original_class INT_VAR class original_class RET original_class END
      ACTION_IF (original_class == 0) BEGIN
        // not a critical issue
        WARN ~WARNING: Ignoring unsupported or unused "original_class" parameter: %value%~
      END
    END

    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    OUTER_SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1

    // dualclass: additional info (is_dualclass, original_class_label, original_level, active_class, active_class_label, active_level)
    OUTER_SET is_dualclass = original_class != 0 && num_classes == 2
    ACTION_IF (is_dualclass) BEGIN
      OUTER_FOR (idx = 1; idx <= num_classes; ++idx) BEGIN
        OUTER_SET cur_class = EVAL ~class%idx%~
        ACTION_IF (cur_class == original_class) BEGIN
          OUTER_SET original_level = EVAL ~level%idx%~
        END ELSE BEGIN
          OUTER_SET active_class = cur_class
          OUTER_SET active_level = EVAL ~level%idx%~
        END
      END
      OUTER_PATCH ~~ BEGIN
        LOOKUP_IDS_SYMBOL_OF_INT original_class_label ~class~ original_class
        LOOKUP_IDS_SYMBOL_OF_INT active_class_label ~class~ active_class
      END

      ACTION_IF (original_level == 1) BEGIN
        OUTER_SET success = 0
        WARN ~WARNING: Original class level must be greater than 1~
      END
    END
  END

  ACTION_IF (success) BEGIN
    // single/multiclass: reference class info (ref_class, ref_level)
    OUTER_SET ref_class = class1
    OUTER_SET ref_level = level1
    ACTION_IF (NOT is_dualclass && num_classes > 1) BEGIN
      // map: class category => weight value (higher = preferred)
      ACTION_DEFINE_ASSOCIATIVE_ARRAY cat_map BEGIN 1 => 1  2 => 4  3 => 3  4 => 2  5 => 0 END
      OUTER_SET cur_weight = 0
      OUTER_FOR (idx = 1; idx <= 3; ++idx) BEGIN
        OUTER_SET cur_class = EVAL ~class%idx%~
        ACTION_IF (cur_class > 0) BEGIN
          LAF a7#get_class_category INT_VAR class = cur_class RET category END
          ACTION_IF (category > 0) BEGIN
            OUTER_SET weight = $cat_map(~%category%~)
            ACTION_IF (weight > cur_weight) BEGIN
              OUTER_SET cur_weight = weight
              OUTER_SET ref_class = cur_class
              OUTER_SET ref_level = EVAL ~level%idx%~
            END
          END
        END
      END
    END

    // loading weapon proficiency table
    SILENT
    COPY_EXISTING ~weapprof.2da~ ~override~
      READ_2DA_ENTRIES_NOW weapprof_table 1
      SET weapprof_def = $weapprof_table(~1~ ~0~)

      // dual/multiclass: marking "forbidden" proficiencies
      PATCH_IF (num_classes > 1) BEGIN
        // consider class and kit
        PATCH_FOR_EACH label IN ~%class_label%~ ~%kit_label%~ BEGIN
          PATCH_IF (NOT ~%label%~ STR_EQ ~~) BEGIN
            SET col = 0
            FOR (header = 3; col == 0 && VARIABLE_IS_SET $weapprof_table(~2~ ~%header%~); ++header) BEGIN
              SPRINT title $weapprof_table(~2~ ~%header%~)
              PATCH_IF (~%title%~ STR_EQ ~%label%~) BEGIN
                SET col = header + 1
              END
            END

            FOR (row = 3; row < weapprof_table; ++row) BEGIN
              SET key = $weapprof_table(~%row%~ ~1~)
              SET value = (col > 0) ? $weapprof_table(~%row%~ ~%col%~) : weapprof_def
              PATCH_IF (NOT VARIABLE_IS_SET $proficiencies(~%key%~)) BEGIN
                SET $proficiencies(~%key%~) = value ? 0 : "-1"
              END ELSE PATCH_IF (value == 0) BEGIN
                SET $proficiencies(~%key%~) = "-1"
              END
            END
          END
        END
      END

      // determine kit/class label to find matching table column
      PATCH_IF (is_dualclass) BEGIN
        // dualclass: find active kit/class
        PATCH_IF (kit_class == active_class && NOT ~%kit_label%~ STR_EQ ~~ && INDEX_BUFFER(~\b%kit_label%\b~) > 0) BEGIN
          SPRINT header_title ~%kit_label%~
        END ELSE PATCH_IF (INDEX_BUFFER(~\b%active_class_label%\b~) > 0) BEGIN
          SPRINT header_title ~%active_class_label%~
        END ELSE BEGIN
          SPRINT header_title ~~
        END
      END ELSE BEGIN
        // single/multiclass
        PATCH_IF (num_classes == 1 && NOT ~%kit_label%~ STR_EQ ~~ && INDEX_BUFFER(~\b%kit_label%\b~) > 0) BEGIN
          SPRINT header_title ~%kit_label%~
        END ELSE PATCH_IF (INDEX_BUFFER(~\b%class_label%\b~) > 0) BEGIN
          SPRINT header_title ~%class_label%~
        END ELSE BEGIN
          SPRINT header_title ~~
        END
      END

      // find matching table column
      SET col = 0
      PATCH_IF (NOT ~%header_title%~ STR_EQ ~~) BEGIN
        FOR (header = 3; col == 0 && VARIABLE_IS_SET $weapprof_table(~2~ ~%header%~); ++header) BEGIN
          SPRINT label $weapprof_table(~2~ ~%header%~)
          PATCH_IF (~%label%~ STR_EQ ~%header_title%~) BEGIN
            SET col = header + 1
          END
        END
      END

      // initializing prof array
      FOR (row = 3; row < weapprof_table; ++row) BEGIN
        SET key = $weapprof_table(~%row%~ ~1~)
        SET value = (col > 0) ? $weapprof_table(~%row%~ ~%col%~) : weapprof_def
        PATCH_IF (NOT VARIABLE_IS_SET $proficiencies(~%key%~) || $proficiencies(~%key%~) >= 0) BEGIN
          SET $proficiencies(~%key%~) = value
        END
      END

      // dualclass: assign higher of both prof values if original class has been reactivated
      PATCH_IF (is_dualclass && active_level > original_level) BEGIN
        PATCH_IF (kit_class == original_class && NOT ~%kit_label%~ STR_EQ ~~ && INDEX_BUFFER(~\b%kit_label%\b~) > 0) BEGIN
          SPRINT header_title ~%kit_label%~
        END ELSE PATCH_IF (INDEX_BUFFER(~\b%original_class_label%\b~) > 0) BEGIN
          SPRINT header_title ~%original_class_label%~
        END ELSE BEGIN
          SPRINT header_title ~~
        END

        SET col = 0
        PATCH_IF (NOT ~%header_title%~ STR_EQ ~~) BEGIN
          FOR (header = 3; col == 0 && VARIABLE_IS_SET $weapprof_table(~2~ ~%header%~); ++header) BEGIN
            SPRINT label $weapprof_table(~2~ ~%header%~)
            PATCH_IF (~%label%~ STR_EQ ~%header_title%~) BEGIN
              SET col = header + 1
            END
          END
        END

        PATCH_IF (col > 0) BEGIN
          FOR (row = 3; row < weapprof_table; ++row) BEGIN
            SET key = $weapprof_table(~%row%~ ~1~)
            SET value = $weapprof_table(~%row%~ ~%col%~)
            SET cur_value = $proficiencies(~%key%~)
            PATCH_IF (cur_value >= 0 && value > cur_value) BEGIN
              SET $proficiencies(~%key%~) = value
            END
          END
        END
      END

      // clearing "forbidden" proficiencies
      FOR (row = 3; row < weapprof_table; ++row) BEGIN
        SET key = $weapprof_table(~%row%~ ~1~)
        PATCH_IF ($proficiencies(~%key%~) < 0) BEGIN
          SET $proficiencies(~%key%~) = 0
        END
      END
    BUT_ONLY
    VERBOSE

    // calculating number of proficiency points to spend
    SILENT
    COPY_EXISTING ~profs.2da~ ~override~
      PATCH_IF (is_dualclass) BEGIN
        SPRINT cur_class_label ~%original_class_label%~
      END ELSE BEGIN
        SPRINT cur_class_label ~%class_label%~
      END

      READ_2DA_ENTRIES_NOW profs_table 1
      FOR (row = 3; row < profs_table; ++row) BEGIN
        SPRINT label $profs_table(~%row%~ ~0~)
        PATCH_IF (~%label%~ STR_EQ ~%cur_class_label%~) BEGIN
          SET first_level = $profs_table(~%row%~ ~1~)
          SET first_level = (first_level < 1) ? 1 : first_level
          SET rate = $profs_table(~%row%~ ~2~)
          SET rate = (rate < 1) ? 50 : rate
          SET row = profs_table
        END
      END

      // getting reference class level
      SET cur_level = is_dualclass ? original_level : ref_level

      SET points_available = first_level + cur_level / rate

      // dualclass: add proficiency points for active class
      PATCH_IF (is_dualclass && active_level > original_level) BEGIN
        FOR (row = 3; row < profs_table; ++row) BEGIN
          SPRINT label $profs_table(~%row%~ ~0~)
          PATCH_IF (~%label%~ STR_EQ ~%active_class_label%~) BEGIN
            SET active_rate = $profs_table(~%row%~ ~2~)
            SET active_rate = (active_rate < 1) ? 50 : active_rate
            SET row = profs_table

            SET start_level = ((original_level + active_rate) / active_rate) * active_rate
            PATCH_IF (active_level >= start_level) BEGIN
              SET points_available += 1 + (active_level - start_level) / active_rate
            END
          END
        END
      END
    BUT_ONLY
    VERBOSE

    // adjusting max. points per proficiency based on current level
    SILENT
    COPY_EXISTING ~profsmax.2da~ ~override~
      PATCH_IF (is_dualclass) BEGIN
        SPRINT cur_class_label ~%active_class_label%~
      END ELSE BEGIN
        SPRINT cur_class_label ~%class_label%~
      END

      READ_2DA_ENTRIES_NOW profsmax_table 1
      // initializing "max_profs" array: key=1: FIRST_LEVEL, key=2: OTHER_LEVELS, other keys: literal min. level
      FOR (row = 3; row < profsmax_table; ++row) BEGIN
        SPRINT label $profsmax_table(~%row%~ ~0~)
        PATCH_IF (~%label%~ STR_EQ ~%cur_class_label%~) BEGIN
          FOR (col = 1; VARIABLE_IS_SET $profsmax_table(~%row%~ ~%col%~); ++col) BEGIN
            SET value = $profsmax_table(~%row%~ ~%col%~)
            SET header_col = col - 1
            SPRINT header $profsmax_table(~2~ ~%header_col%~)
            PATCH_IF (header_col == 0) BEGIN
              SET $max_profs(~1~) = value
            END ELSE PATCH_IF (header_col == 1) BEGIN
              // OTHER_LEVELS: set for compatibility with older game versions
              SET $max_profs(~2~) = value
            END ELSE PATCH_IF (IS_AN_INT ~header~) BEGIN
              SET header = header
              SET $max_profs(~%header%~) = value
              PATCH_IF (header > 2) BEGIN
                SET $max_profs(~2~) = $max_profs(~1~) // reset compatibility entry
              END
            END
          END
          SET row = profsmax_table
        END
      END

      // finding matching level entry
      SET cur_level = is_dualclass ? active_level : ref_level
      SET match = 1
      PHP_EACH max_profs AS key => value BEGIN
        PATCH_IF (cur_level >= key && key > match) BEGIN
          SET match = key
        END
      END

      // adjusting proficiency max. points
      SET max_value = $max_profs(~%match%~)
      PHP_EACH proficiencies AS key => value BEGIN
        PATCH_IF (max_value < value) BEGIN
          SET $proficiencies(~%key%~) = max_value
        END
      END
    BUT_ONLY
    VERBOSE
  END
END


/**
 * Returns number of available spell slots as well as number of known spells for the specified class.
 *
 * INT_VAR class                    Numeric class value (CLASS.IDS).
 * INT_VAR kit                      Numeric kit value (KIT.IDS).
 * INT_VAR level1                   Level of the first base class.
 * INT_VAR level2                   Level of the second base class for dual- or multiclasses. (Default: 0)
 * INT_VAR level3                   Level of the third base class for triple classes. (Default: 0)
 * INT_VAR original_class           For dual-class characters only: Specifies the numeric value of the original
 *                                  class (CLASS.IDS). (Default: 0)
 * INT_VAR wis                      Wisdom score of the character. This value may influence number of priest slots. (Default: 0)
 * RET success                      Returns 1 if the operation completed successfully, 0 otherwise.
 * RET_ARRAY slots_priest_memorize  An associative array with the number of available priest slots for levels 1 to 7
 *                                  as "level" => "num_slots" entries.
 * RET_ARRAY slots_wizard_memorize  An associative array with the number of available wizard slots for levels 1 to 9
 *                                  as "level" => "num_slots" entries.
 * RET_ARRAY slots_spells_known     For sorcerers and shamans only: An associative array with the number of available
 *                                  known spells for each wizard or priest level as "level" => "num_spells" entries.
 */
DEFINE_DIMORPHIC_FUNCTION a7#calculate_spell_slots
INT_VAR
  class = 0
  kit = 0
  level1 = 0
  level2 = 0
  level3 = 0
  original_class = 0
  wis = 0
RET
  success
RET_ARRAY
  slots_priest_memorize
  slots_wizard_memorize
  slots_spells_known
BEGIN
  OUTER_SET success = (class > 0 && class < 22)
  ACTION_IF (NOT success) BEGIN
    WARN ~WARNING: Invalid class: %class%~
  END

  ACTION_IF (success) BEGIN
    // initializing kit if defined
    LAF a7#get_kit_info INT_VAR kit RET kit_label kit_class kit_unusability END

    // evaluating original class if defined
    ACTION_IF (original_class != 0) BEGIN
      OUTER_SET value = original_class
      LAF a7#evaluate_original_class INT_VAR class original_class RET original_class END
      ACTION_IF (original_class == 0) BEGIN
        // not a critical issue
        WARN ~WARNING: Ignoring unsupported or unused "original_class" parameter: %value%~
      END
    END

    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    OUTER_SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1

    // dualclass requires additional preparations
    OUTER_SET is_dualclass = original_class != 0 && num_classes == 2
    ACTION_IF (is_dualclass) BEGIN
      OUTER_FOR (idx = 1; idx <= num_classes; ++idx) BEGIN
        OUTER_SET cur_class = EVAL ~class%idx%~
        ACTION_IF (cur_class == original_class) BEGIN
          OUTER_SET original_level = EVAL ~level%idx%~
        END ELSE BEGIN
          OUTER_SET active_class = cur_class
          OUTER_SET active_level = EVAL ~level%idx%~
        END
      END

      ACTION_IF (active_level > original_level) BEGIN
        // both classes active? treat as multiclass
        OUTER_SET original_class = 0
      END ELSE BEGIN
        // otherwise treat as single class
        OUTER_SET num_classes = 1
        OUTER_SET class = active_class
        OUTER_SET class1 = class
        OUTER_SET level1 = active_level
        OUTER_SET class2 = 0
        OUTER_SET level2 = 0
      END

      ACTION_IF (original_level == 1) BEGIN
        OUTER_SET success = 0
        WARN ~WARNING: Original class level must be greater than 1~
      END
    END
  END

  ACTION_IF (success) BEGIN
    ACTION_DEFINE_ASSOCIATIVE_ARRAY max_slots_tables BEGIN
      // class/kit label => 2da resref
      ~BARD~            => ~mxsplbrd~
      ~DRAGON_DISCIPLE~ => ~mxspldd~
      ~DRUID~           => ~mxspldru~
      ~PALADIN~         => ~mxsplpal~
      ~CLERIC~          => ~mxsplprs~
      ~RANGER~          => ~mxsplran~
      ~SHAMAN~          => ~mxsplshm~
      ~SORCERER~        => ~mxsplsrc~
      ~MAGE~            => ~mxsplwiz~
    END
    ACTION_DEFINE_ASSOCIATIVE_ARRAY known_spells_tables BEGIN
      // class label => 2da resref
      ~SHAMAN~    => ~splshmkn~
      ~SORCERER~  => ~splsrckn~
    END
    ACTION_DEFINE_ASSOCIATIVE_ARRAY forbid_spells_table BEGIN
      // kit label => whether spellcasting is forbidden
      ~INQUISITOR~ => 1
    END

    // initializing table of wisdom-based bonus spell slots for clerics and druids: "mxsplwis" with ("wis" "spell_level") => "bonus" entries
    SILENT
    COPY_EXISTING ~mxsplwis.2da~ ~override~
      // column=0: WIS score, columns 1..7: bonus slots per spell level
      READ_2DA_ENTRIES_NOW mxsplwis_table 1
      FOR (row = 3; row < mxsplwis_table; ++row) BEGIN
        SPRINT header $mxsplwis_table(~%row%~ ~0~)
        PATCH_IF (IS_AN_INT ~header~) BEGIN
          SET header = header // normalizing score
          FOR (col = 1; VARIABLE_IS_SET $mxsplwis_table(~%row%~ ~%col%~); ++col) BEGIN
            SET $mxsplwis(~%header%~ ~%col%~) = $mxsplwis_table(~%row%~ ~%col%~)
          END
        END
      END
    BUT_ONLY
    VERBOSE

    // initializing return arrays
    OUTER_FOR (i = 1; i <= 9; ++i) BEGIN
      OUTER_SET $slots_wizard_memorize(~%i%~) = 0
      OUTER_SET $slots_spells_known(~%i%~) = 0
      ACTION_IF (i <= 7) BEGIN
        OUTER_SET $slots_priest_memorize(~%i%~) = 0
      END
    END

    OUTER_FOR (cls_idx = 1; cls_idx <= num_classes; ++cls_idx) BEGIN
      OUTER_SET cur_class = EVAL ~class%cls_idx%~
      OUTER_SET cur_level = EVAL ~level%cls_idx%~
      OUTER_PATCH ~~ BEGIN  LOOKUP_IDS_SYMBOL_OF_INT cur_class_label ~class~ cur_class END

      // determine max. slots per spell level (includes specialist mage and WIS-based bonuses)
      ACTION_IF (VARIABLE_IS_SET $max_slots_tables(~%cur_class_label%~)) BEGIN
        // storing the right array variable for the current class into the "array" string
        ACTION_MATCH cur_class WITH
          3 6 11 12 21 BEGIN OUTER_SPRINT array ~slots_priest_memorize~ END
          1 5 19 BEGIN OUTER_SPRINT array ~slots_wizard_memorize~ END
          DEFAULT OUTER_SPRINT array ~~
        END

        // applying exceptions
        ACTION_IF (~%array%~ STR_EQ ~slots_priest_memorize~) BEGIN
          // Paladin Inquisitor kit does not receive priest spells
          OUTER_SET MASK_INQUISITOR = 0x00000010
          ACTION_IF ((kit_unusability & MASK_INQUISITOR) != 0) BEGIN
            OUTER_SPRINT array ~~
          END
        END

        // some kits forbid any spellcasting
        ACTION_IF (VARIABLE_IS_SET $forbid_spells_table(~%kit_label%~) && $forbid_spells_table(~%kit_label%~) != 0) BEGIN
          OUTER_SPRINT array ~~
        END

        ACTION_IF (NOT ~%array%~ STR_EQ ~~) BEGIN
          // determine max. slots per spell level
          ACTION_IF (VARIABLE_IS_SET $max_slots_tables(~%kit_label%~)) BEGIN
            OUTER_SPRINT resref $max_slots_tables(~%kit_label%~)
          END ELSE BEGIN
            OUTER_SPRINT resref $max_slots_tables(~%cur_class_label%~)
          END
          SILENT
          COPY_EXISTING ~%resref%.2da~ ~override~
            READ_2DA_ENTRIES_NOW ~%resref%_table~ 1
            FOR (row = 3; row < EVAL ~%resref%_table~; ++row) BEGIN
              SPRINT header $EVAL ~%resref%_table~(~%row%~ ~0~)
              PATCH_IF (row + 1 == EVAL ~%resref%_table~) BEGIN
                // failsafe: use values from max. defined level
                SET header = cur_level
              END
              PATCH_IF (IS_AN_INT ~header~ && header == cur_level) BEGIN
                FOR (col = 1; VARIABLE_IS_SET $EVAL ~%resref%_table~(~%row%~ ~%col%~); ++col) BEGIN
                  SET header_col = col - 1
                  SPRINT spell_level $EVAL ~%resref%_table~(~2~ ~%header_col%~)
                  SPRINT num_slots $EVAL ~%resref%_table~(~%row%~ ~%col%~)
                  PATCH_IF (IS_AN_INT ~spell_level~ && IS_AN_INT ~num_slots~) BEGIN
                    PATCH_IF (num_slots > 0) BEGIN
                      PATCH_IF (cur_class == 1 && (kit_unusability & SPECIALIST_MAGE_MASK) != 0) BEGIN
                        // applying specialist mage bonus
                        SET num_slots += 1
                      END ELSE PATCH_IF (~%array%~ STR_EQ ~slots_priest_memorize~ && (cur_class == 3 || cur_class == 11)) BEGIN
                        // applying WIS-based bonus for clerics/druids
                        PATCH_IF (VARIABLE_IS_SET $mxsplwis(~%wis%~ ~%spell_level%~)) BEGIN
                          SET num_slots += $mxsplwis(~%wis%~ ~%spell_level%~)
                        END
                      END
                    END
                    SET value = (VARIABLE_IS_SET $EVAL ~%array%~(~%spell_level%~)) ? $EVAL ~%array%~(~%spell_level%~) : 0
                    SET value = (num_slots > value) ? num_slots : value
                    SET $EVAL ~%array%~(~%spell_level%~) = value
                  END
                END
                SET row = EVAL ~%resref%_table~
              END
            END
          BUT_ONLY
          VERBOSE
        END
      END

      // determine known spells per spell level
      ACTION_IF (VARIABLE_IS_SET $known_spells_tables(~%cur_class_label%~)) BEGIN
        OUTER_SPRINT resref $known_spells_tables(~%cur_class_label%~)
        SILENT
        COPY_EXISTING ~%resref%.2da~ ~override~
          READ_2DA_ENTRIES_NOW ~%resref%_table~ 1
          FOR (row = 3; row < EVAL ~%resref%_table~; ++row) BEGIN
            SPRINT header $EVAL ~%resref%_table~(~%row%~ ~0~)
            PATCH_IF (row + 1 == EVAL ~%resref%_table~) BEGIN
              // failsafe: use values from max. defined level
              SET header = cur_level
            END
            PATCH_IF (IS_AN_INT ~header~ && header == cur_level) BEGIN
              FOR (col = 1; VARIABLE_IS_SET $EVAL ~%resref%_table~(~%row%~ ~%col%~); ++col) BEGIN
                SET header_col = col - 1
                SPRINT spell_level $EVAL ~%resref%_table~(~2~ ~%header_col%~)
                SPRINT num_spells $EVAL ~%resref%_table~(~%row%~ ~%col%~)
                PATCH_IF (IS_AN_INT ~spell_level~ && IS_AN_INT ~num_spells~) BEGIN
                  SET $slots_spells_known(~%spell_level%~) = num_spells
                END
              END
              SET row = EVAL ~%resref%_table~
            END
          END
        BUT_ONLY
        VERBOSE
      END
    END
  END
END

/**
 * Returns the class category of the specified class. This function works only on single classes or individual class aspects
 * of dual- and multiclasses.
 *
 * INT_VAR class  Numeric class value (CLASS.IDS).
 * RET category   Category value of the given class (CLASSCAT.IDS) plus MONK category.
 *                Returns -1 if the category could not be determined.
 *                Values: 1=WIZARD, 2=WARRIOR, 3=PRIEST, 4=ROGUE, 5=MONK
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_class_category
INT_VAR
  class = 0
RET
  category
BEGIN
  ACTION_MATCH class WITH
    1 19    BEGIN OUTER_SET category = 1 END
    2 6 12  BEGIN OUTER_SET category = 2 END
    3 11 21 BEGIN OUTER_SET category = 3 END
    4 5     BEGIN OUTER_SET category = 4 END
    20      BEGIN OUTER_SET category = 5 END
    DEFAULT
      OUTER_SET category = "-1"
  END
END


/**
 * Checks if an original class is defined and addresses a class aspect of the dual-class.
 *
 * INT_VAR class            Numeric value of the dual-class combination (CLASS.IDS).
 * INT_VAR original_class   Numeric value of the original class (CLASS.IDS). (Default: 0)
 * RET original_class       Value of the "original_class" parameter if a match was found, 0 otherwise.
 */
DEFINE_DIMORPHIC_FUNCTION a7#evaluate_original_class
INT_VAR
  class = 0
  original_class = 0
RET
  original_class
BEGIN
  ACTION_IF (original_class != 0) BEGIN
    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    OUTER_SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1
    ACTION_IF (num_classes == 2) BEGIN
      OUTER_SET match = 0
      OUTER_FOR (i = 1; i <= 2 && NOT match; ++i) BEGIN
        OUTER_SET cur_class = EVAL ~class%i%~
        OUTER_SET match = cur_class > 0 && cur_class = original_class
      END
      ACTION_IF (NOT match) BEGIN
        OUTER_SET original_class = 0
      END
    END
  END
END


/**
 * Returns the individual class levels based on the specified parameters. Calling this function is mostly useful for
 * dual- or multiclass characters.
 *
 * INT_VAR xp               Total experience points. This value includes xp spent on the original class of dual-class
 *                          characters.
 * INT_VAR class            Numeric class value (CLASS.IDS). Allows single/dual/multiclass values.
 * INT_VAR original_class   For dual-class characters only: Numeric value of the original class (CLASS.IDS). (Default: 0)
 * INT_VAR original_level   For dual-class characters only: Level of the original class when the character switched to the
 *                          second class. This level may be reduced if insufficient xp is specified. The effective level
 *                          is assigned to one of the "level1" or "level2" return values. (Default: 0)
 * RET xp                   For dualclass characters, this is the remaining experience after removing the original class
 *                          level. Otherwise, this is the unmodified value of the "xp" parameter.
 * RET level1               Level of the first class aspect of "class". This is "class" itself for single-class characters.
 *                          Returns 0 if class level could not be determined.
 *                          Note: Since dualclassing requires the original class to be level 2 or higher, if the original
 *                          class level of a dual-class definition is 1 then the class is internally transformed into a
 *                          single-class and "level1" returns the level of "original_class". 
 * RET level2               Level of the second class aspect of "class" for dual- or multiclass characters, 0 otherwise.
 * RET level3               Level of the third class aspect of "class" for triple class characters, 0 otherwise.
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_class_levels
INT_VAR
  xp = 0
  class = 0
  original_class = 0
  original_level = 0
RET
  xp
  level1
  level2
  level3
BEGIN
  OUTER_SET xp = (xp < 0) ? 0 : xp
  OUTER_FOR (i = 1; i <= 3; ++i) BEGIN OUTER_SET EVAL ~level%i%~ = 0 END

  LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
  ACTION_IF (class1 > 0) BEGIN
    OUTER_SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1
    SILENT
    COPY_EXISTING ~xplevel.2da~ ~override~
      READ_2DA_ENTRIES_NOW xplevel_table 1

      // handling original class of dual-classes first
      SET is_dualclass = num_classes == 2 && original_class > 0 && original_level > 1
      PATCH_IF (is_dualclass) BEGIN
        SET handled = 0
        FOR (cls_idx = 1; cls_idx <= num_classes; ++cls_idx) BEGIN
          SET cur_class = EVAL ~class%cls_idx%~
          LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ cur_class
          PATCH_IF (cur_class == original_class) BEGIN
            FOR (row = 3; row < xplevel_table; ++row) BEGIN
              SPRINT label $xplevel_table(~%row%~ ~0~)
              PATCH_IF (~%label%~ STR_EQ ~%class_label%~) BEGIN
                // fix original class level if not enough xp is available
                FOR (col = original_level; col > 0; --col) BEGIN
                  PATCH_IF (VARIABLE_IS_SET $xplevel_table(~%row%~ ~%col%~)) BEGIN
                    SET value = $xplevel_table(~%row%~ ~%col%~)
                    PATCH_IF (xp >= value) BEGIN
                      SET xp -= value
                      SET EVAL ~level%cls_idx%~ = col
                      PATCH_IF (col == 1) BEGIN
                        // dualclassing at level 1 not allowed => switching to single-class
                        SET class = cur_class
                        SET class1 = cur_class
                        SET class2 = 0
                        SET num_classes = 1
                        SET is_dualclass = 0
                      END
                      SET col = 0
                      SET handled = 1
                    END
                  END
                END
                SET row = xplevel_table
              END
            END
          END
        END

        PATCH_IF (NOT handled) BEGIN
          SET original_class = 0
          SET original_level = 0
          SET is_dualclass = 0
        END
      END ELSE BEGIN
        SET original_class = 0
        SET original_level = 0
      END

      SET cur_xp = is_dualclass ? xp : xp / num_classes

      // handling active classes
      FOR (cls_idx = 1; cls_idx <= num_classes; ++cls_idx) BEGIN
        SET cur_class = EVAL ~class%cls_idx%~
        PATCH_IF (cur_class != original_class) BEGIN
          LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ cur_class
          FOR (row = 3; row < xplevel_table; ++row) BEGIN
            SPRINT label $xplevel_table(~%row%~ ~0~)
            PATCH_IF (~%label%~ STR_EQ ~%class_label%~) BEGIN
              SET cur_level = 0
              FOR (col = 1; VARIABLE_IS_SET $xplevel_table(~%row%~ ~%col%~); ++col) BEGIN
                SET value = $xplevel_table(~%row%~ ~%col%~)
                PATCH_IF (value >= 0 && cur_xp >= value && col > cur_level) BEGIN
                  SET cur_level = col
                END
              END
              SET EVAL ~level%cls_idx%~ = cur_level
              SET row = xplevel_table
            END
          END
        END
      END
    BUT_ONLY
    VERBOSE
  END
END


/**
 * Returns the individual class aspects of the given class. For single classes this is the specified class.
 * For multi classes this is two or three base classes in the order of application by the engine.
 *
 * INT_VAR class  Numeric class value (CLASS.IDS).
 * RET class1     Numeric value of the first base class. Returns -1 if "class" parameter contains an invalid character class.
 * RET class2     Numeric value of the second base class for valid dual- and multiclasses. Returns -1 otherwise.
 * RET class3     Numeric value of the third base class for valid multiclasses with three base classes. Returns -1 otherwise.
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_base_classes
INT_VAR
  class = "-1"
RET
  class1
  class2
  class3
BEGIN
  OUTER_SET class1 = "-1"
  OUTER_SET class2 = "-1"
  OUTER_SET class3 = "-1"

  ACTION_IF (class > 0 && class < 22) BEGIN
    OUTER_PATCH ~~ BEGIN
      LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ class
    END

    ACTION_IF (NOT IS_AN_INT ~class_label~) BEGIN
      OUTER_SET len = STRING_LENGTH ~%class_label%~
      OUTER_PATCH ~%class_label%~ BEGIN
        SET idx = 1
        SET p1 = 0
        WHILE (p1 >= 0) BEGIN
          SET p2 = INDEX_BUFFER(~_~ p1)
          SET p2 = (p2 < 0) ? len : p2
          PATCH_IF (p2 > p1) BEGIN
            READ_ASCII p1 s (p2 - p1)
            SET id = IDS_OF_SYMBOL(~class~ ~%s%~)
            PATCH_IF (id > 0) BEGIN
              SET EVAL ~class%idx%~ = id
            END
            SET idx += 1
            SET p1 = (p2 < len) ? p2 + 1 : "-1"
          END ELSE BEGIN
            SET p1 = "-1"
          END
        END
      END
    END
  END
END


/**
 * Returns additional information about the specified kit.
 *
 * INT_VAR kit            Numeric kit value (KIT.IDS).
 * RET kit_label          Symbolic label of the kit. Returns empty string if the kit does not exist.
 * RET kit_class          Numeric value of the class the specified kit belongs to. Returns -1 if the kit does not exist.
 * RET kit_unusability    Numeric value of the kit's usability flags. Returns 0 if the kit does not exist.
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_kit_info
INT_VAR
  kit = 0
RET
  kit_label
  kit_class
  kit_unusability
BEGIN
  OUTER_SPRINT kit_label ~~
  OUTER_SET kit_class = "-1"
  OUTER_SET kit_unusability = 0

  ACTION_IF (kit != 0 && kit != TRUECLASS) BEGIN
    LAF a7#convert_kit_label INT_VAR kit RET kit_label END
    ACTION_IF (NOT ~%kit_label%~ STR_EQ ~~) BEGIN
      SILENT
      COPY_EXISTING ~kitlist.2da~ ~override~
        READ_2DA_ENTRIES_NOW kitlist_table 1
        FOR (row = 4; row < kitlist_table; ++row) BEGIN
          SPRINT kitids $kitlist_table(~%row%~ ~9~)
          PATCH_IF (IS_AN_INT ~kitids~) BEGIN
            PATCH_IF (kitids == kit) BEGIN
              SET kit_class = $kitlist_table(~%row%~ ~8~)
              SET kit_unusability = $kitlist_table(~%row%~ ~7~)
              SET row = kitlist_table
            END
          END
        END
      BUT_ONLY
      VERBOSE
    END
  END
END


/**
 * Attempts to resolve the given string into a valid SPL resource reference.
 *
 * STR_VAR spell  A string that identifies a spell resource. Supported types: SPL resrefs, numeric or symbolic SPELL.IDS definitions.
 * RET resref     A valid SPL resref if successful, an empty string otherwise.
 */
DEFINE_DIMORPHIC_FUNCTION a7#resolve_spell_resref
STR_VAR
  spell = ~~
RET
  resref
BEGIN
  OUTER_SPRINT resref ~~

  ACTION_IF (NOT ~%spell%~ STR_EQ ~~) BEGIN
    // determining SPL resref
    ACTION_IF (FILE_EXISTS_IN_GAME ~%spell%.SPL~) BEGIN
      OUTER_SPRINT resref ~%spell%~
    END ELSE BEGIN
      OUTER_SET spell_num = IS_AN_INT ~spell~ ? spell : IDS_OF_SYMBOL(~spell~ ~%spell%~)
      ACTION_IF (spell_num > 0) BEGIN
        LAF RES_NAME_OF_SPELL_NUM INT_VAR spell_num RET resref = spell_res END
      END ELSE BEGIN
        OUTER_SPRINT resref ~~
      END
    END
    ACTION_TO_UPPER ~resref~
  END
END

/**
 * Returns details about the specified spell resource.
 *
 * STR_VAR resref   Resref of the SPL resource.
 * RET spell_type   Returns the spell type (0=PRIEST, 1=WIZARD, 2=INNATE, 3=OTHER)
 * RET school       Returns the primary spell school.
 * RET secondary    Returns the secondary type.
 * RET level        Returns the spell level.
 * RET flags        Returns spell flags.
 * RET exclusion    Returns the exclusion flags of the spell. Flag bits depend on the spell type.
 * RET name         Returns the spell name, as string.
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_spell_info
STR_VAR
  resref = ~~
RET
  spell_type
  school
  secondary
  level
  flags
  exclusion
  name
BEGIN
  OUTER_SET spell_type = 0
  OUTER_SET school = 0
  OUTER_SET secondary = 0
  OUTER_SET level = 0
  OUTER_SET flags = 0
  OUTER_SET exclusion = 0
  OUTER_SPRINT name ~~

  ACTION_IF (NOT ~%resref%~ STR_EQ ~~) BEGIN
    SILENT
    COPY_EXISTING ~%resref%.spl~ ~override~
      READ_ASCII 0 sig (8)
      PATCH_IF (~%sig%~ STR_EQ ~SPL V1  ~) BEGIN
        READ_STRREF NAME1 name
        READ_LONG 0x18 flags
        READ_SHORT 0x1c type
        PATCH_MATCH type WITH
          1 BEGIN SET spell_type = 1 END
          2 BEGIN SET spell_type = 0 END
          4 BEGIN SET spell_type = 2 END
          DEFAULT SET spell_type = 3
        END
        READ_LONG 0x1e exclusion
        READ_BYTE 0x25 school
        READ_BYTE 0x27 secondary
        READ_LONG 0x34 level
      END
    BUT_ONLY IF_EXISTS
    VERBOSE
  END
END


/**
 * Returns whether the specified CRE and SPL parameters are compatible.
 *
 * INT_VAR class        Numeric class value of the CRE (CLASS.IDS).
 * INT_VAR kit          Numeric kit value of the CRE (KIT.IDS).
 * INT_VAR alignment    Numeric alignment value of the CRE (ALIGNMEN.IDS).
 * INT_VAR spell_type   Type of the SPL (0: Priest, 1: Wizard, 2: Innate).
 * INT_VAR exclusion    Exclusion flags (meaning depends on spell type).
 * RET usable           Returns a boolean value that indicates whether SPL and CRE parameters are compatible.
 */
DEFINE_DIMORPHIC_FUNCTION a7#is_spell_usable
INT_VAR
  class = 0
  kit = 0
  alignment = 0
  spell_type = 0
  exclusion = 0
RET
  usable
BEGIN
  OUTER_SET usable = 1

  LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
  ACTION_IF (spell_type == 0) BEGIN
    // priest spell
    ACTION_DEFINE_ASSOCIATIVE_ARRAY usability BEGIN
      // exclusion bit, type => attribute type
      // exclusion bit, value => attribute value
      ~%BIT2%~, ~type~    => ~align~
      ~%BIT2%~, ~value~   => 0x01
      ~%BIT3%~, ~type~    => ~align~
      ~%BIT3%~, ~value~   => 0x02
      ~%BIT1%~, ~type~    => ~align~
      ~%BIT1%~, ~value~   => 0x03
      ~%BIT4%~, ~type~    => ~align~
      ~%BIT4%~, ~value~   => 0x10
      ~%BIT5%~, ~type~    => ~align~
      ~%BIT5%~, ~value~   => 0x20
      ~%BIT0%~, ~type~    => ~align~
      ~%BIT0%~, ~value~   => 0x30
      ~%BIT30%~, ~type~   => ~class~
      ~%BIT30%~, ~value~  => ~CLERIC_PALADIN~
      ~%BIT31%~, ~type~   => ~class~
      ~%BIT31%~, ~value~  => ~DRUID_RANGER_SHAMAN~
    END

    OUTER_SET class_mask = 0
    OUTER_FOR (bit_idx = 0; bit_idx < 32; ++bit_idx) BEGIN
      OUTER_SET key = 1 << bit_idx
      ACTION_IF (VARIABLE_IS_SET $usability(~%key%~ ~type~)) BEGIN
        OUTER_SPRINT type $usability(~%key%~ ~type~)
        ACTION_IF (~%type%~ STR_EQ ~align~) BEGIN
          // checking alignment
          ACTION_IF ((exclusion & key) != 0) BEGIN
            OUTER_SET value = $usability(~%key%~ ~value~)
            OUTER_SET mask = (value & 3) != 0 ? 0x03 : 0x30
            OUTER_SET usable = usable && (alignment & mask) != value
          END
        END ELSE ACTION_IF (~%type%~ STR_EQ ~class~) BEGIN
          // building class mask
          OUTER_SPRINT value $usability(~%key%~ ~value~)
          OUTER_FOR (idx = 1; idx <= 3; ++idx) BEGIN
            OUTER_SET cur_class = EVAL ~class%idx%~
            ACTION_IF (cur_class > 0) BEGIN
              OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT cur_class_label ~class~ cur_class END
              ACTION_IF (~%value%~ STRING_CONTAINS_REGEXP ~%cur_class_label%~ == 0) BEGIN
                OUTER_SET class_mask |= key
              END
            END
          END
        END
      END
    END
    OUTER_SET usable = usable && (exclusion & class_mask) != class_mask
  END ELSE ACTION_IF (spell_type == 1) BEGIN
    // wizard spell
    OUTER_SET exclusion_mask = exclusion & SPECIALIST_MAGE_MASK
    LAF a7#get_kit_info INT_VAR kit RET kit_label kit_class kit_unusability END
    OUTER_FOR (idx = 1; usable && idx <= 3; ++idx) BEGIN
      OUTER_SET cur_class = EVAL ~class%idx%~
      ACTION_IF (cur_class == 1) BEGIN
        OUTER_SET usable = (kit_unusability & exclusion_mask) == 0
      END
    END
  END
END


/**
 * Returns mage usability bits as well as the first matching magic school identifier of the specified specialist mage kit id.
 *
 * INT_VAR unusable   The kit's unusable mask (see KITLIST.2DA). (Default: 0x4000 - MAGESCHOOL_GENERALIST)
 * RET unusable       Normalized usability bit mask for specialist mage schools.
 * RET school         Numeric identifier of the magic school associated with the mage kit. Returns 9 (GENERALIST)
 *                    if an unsupported specialist mage kit was specified.
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_mage_kit_school
INT_VAR
  unusable = 0x4000
RET
  unusable
  school
BEGIN
  ACTION_DEFINE_ASSOCIATIVE_ARRAY schools_array BEGIN
    // kit id => school id
    ~%BIT6%~  => 1  // MAGESCHOOL_ABJURER
    ~%BIT7%~  => 2  // MAGESCHOOL_CONJURER
    ~%BIT8%~  => 3  // MAGESCHOOL_DIVINER
    ~%BIT9%~  => 4  // MAGESCHOOL_ENCHANTER
    ~%BIT10%~ => 5  // MAGESCHOOL_ILLUSIONIST
    ~%BIT11%~ => 6  // MAGESCHOOL_INVOKER
    ~%BIT12%~ => 7  // MAGESCHOOL_NECROMANCER
    ~%BIT13%~ => 8  // MAGESCHOOL_TRANSMUTER
    ~%BIT31%~ => 10 // WILDMAGE
  END

  OUTER_SET unusable &= SPECIALIST_MAGE_MASK

  OUTER_SET school = 0
  ACTION_PHP_EACH schools_array AS bit => id BEGIN
    ACTION_IF (school == 0 && (unusable & bit) != 0) BEGIN
      OUTER_SET school = id
    END
  END

  ACTION_IF (school == 0) BEGIN
    // falling back to generalist
    OUTER_SET school = 9
    OUTER_SET unusable = 0x4000
  END
END


/**
 * Returns an indexed array with a random choice of mage spells that are compatible with the given parameters.
 * For specialist mages the first pick will always be a spell of the school of their specialization.
 *
 * INT_VAR unusable   The kit's unusable mask (see KITLIST.2DA). (Default: 0x4000 - MAGESCHOOL_GENERALIST)
 * INT_VAR level      Spell level to pick spell from. Supported range: [1, 9]
 * INT_VAR count      Number of spell choices to return in the "spells" array. Actual number may be smaller if
 *                    not enough spells are available. (Default: 1)
 * RET spells         Number of entries in the "spells" array.
 * RET_ARRAY spells   Indexed array with spell resrefs that are compatible with the given parameters. For specialist
 *                    mages the first pick will always be a spell from the school of specialization if available.
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_spell_picks
INT_VAR
  unusable = 0x4000
  level = 0
  count = 1
RET
  spells
RET_ARRAY
  spells
BEGIN
  OUTER_SET spells = 0
  OUTER_SET success = (level >= 1 && level <= 9)

  ACTION_IF (success) BEGIN
    // initializations
    OUTER_SET WILDMAGE_MASK = SPECIALIST_MAGE_MASK BAND BNOT BIT31

    // normalizing mage kit
    LAF a7#get_mage_kit_school INT_VAR unusable RET unusable mage_school = school END

    // checking count
    OUTER_SET success = (count > 0)
  END

  ACTION_IF (success) BEGIN
    // collecting available spells
    OUTER_SET min_id = 2001 + level * 100
    OUTER_SET max_id = min_id + 50
    SILENT
    COPY_EXISTING ~spell.ids~ ~override~
      READ_2DA_ENTRIES_NOW spell_table 1
      FOR (row = 1; row < spell_table; ++row) BEGIN
        PATCH_IF (IS_AN_INT $spell_table(~%row%~ ~0~)) BEGIN
          SET id = $spell_table(~%row%~ ~0~)
          PATCH_IF (id >= min_id && id <= max_id) BEGIN
            SET code = id MODULO 1000
            SPRINT resref ~SPWI%code%~
            PATCH_IF (FILE_EXISTS_IN_GAME ~%resref%.SPL~) BEGIN
              SET $spells_map(~%resref%~) = 1
            END
          END
        END
      END
    BUT_ONLY
    VERBOSE

    // disabling hidden spells
    SILENT
    COPY_EXISTING ~hidespl.2da~ ~override~
      READ_2DA_ENTRIES_NOW hidespl_table 1
      FOR (row = 3; row < hidespl_table; ++row) BEGIN
        SPRINT resref $hidespl_table(~%row%~ ~0~)
        TO_UPPER ~resref~
        PATCH_IF (VARIABLE_IS_SET $spells_map(~%resref%~)) BEGIN
          SET is_hidden = $hidespl_table(~%row%~ ~1~)
          PATCH_IF (is_hidden) BEGIN
            SET $spells_map(~%resref%~) = 0
          END
        END
      END
    BUT_ONLY
    VERBOSE

    // filtering spells by school and exclusions
    OUTER_SET spells_array = 0
    OUTER_SET spell_of_school = 0
    ACTION_PHP_EACH spells_map AS resref => available BEGIN
      ACTION_IF (available) BEGIN
        LAF a7#get_spell_info STR_VAR resref RET spell_type school secondary level flags exclusion name END
        ACTION_IF (spell_type == 1) BEGIN
          ACTION_IF ((exclusion & unusable) == 0) BEGIN
            OUTER_SPRINT $spells_array(~%spells_array%~) ~%resref%~
            OUTER_SET spells_array += 1
            ACTION_IF (school == mage_school) BEGIN
              OUTER_SPRINT $spell_of_school(~%spell_of_school%~) ~%resref%~
              OUTER_SET spell_of_school += 1
            END ELSE ACTION_IF (unusable == BIT31 && (exclusion & SPECIALIST_MAGE_MASK) == WILDMAGE_MASK) BEGIN
              // spell is considered as being exclusive for Wild Mages
              OUTER_SPRINT $spell_of_school(~%spell_of_school%~) ~%resref%~
              OUTER_SET spell_of_school += 1
            END
          END
        END
      END
    END

    // populating spell picks
    OUTER_SET num_spells = spells_array
    ACTION_IF (spell_of_school > 0) BEGIN
      // choose a specialist school pick first
      OUTER_SET idx = RANDOM(0 spell_of_school - 1)
      OUTER_SPRINT resref $spell_of_school(~%idx%~)
      OUTER_SET $spells_map(~%resref%~) = 0
      OUTER_SPRINT $spells(~%spells%~) ~%resref%~
      OUTER_SET spells += 1
      OUTER_SET num_spells -= 1
    END

    // fill remaining array with non-specific spells
    OUTER_WHILE (spells < count && num_spells > 0) BEGIN
      // by default spell index is chosen randomly
      ACTION_IF (num_spells > 1) BEGIN
        OUTER_SET idx = RANDOM(0 spells_array - 1)
      END ELSE BEGIN
        // changing strategy to speed up index-choosing
        OUTER_FOR (i = 0; i < spells_array; ++i) BEGIN
          ACTION_IF ($spells_array(~%i%~) != 0) BEGIN
            OUTER_SET idx = i
            OUTER_SET i = spells_array
          END
        END
      END

      OUTER_SPRINT resref $spells_array(~%idx%~)
      ACTION_IF ($spells_map(~%resref%~) != 0) BEGIN
        OUTER_SET $spells_map(~%resref%~) = 0
        OUTER_SPRINT $spells(~%spells%~) ~%resref%~
        OUTER_SET spells += 1
        OUTER_SET num_spells -= 1
      END
    END
  END
END

/**
 * Returns an indexed array with all known priest and/or druid spells that are compatible with the
 * given parameters.
 *
 * INT_VAR cleric           Indicates whether cleric/paladin spells should be added. (Default: 0)
 * INT_VAR druid            Indicates whether druid/ranger/shaman spells should be added. (Default: 0)
 * INT_VAR cleric_level     Specifies the max. level for adding cleric spells. (Default: 7)
 * INT_VAR druid_level      Specifies the max. level for adding druid spells. (Default: 7)
 * INT_VAR alignment        Alignmnent (see ALIGNMEN.IDS) of the character to filter spells with alignment requirements.
 *                          (Default: 0 [NONE])
 * RET known_spells         Number of entries in the "known_spells" array.
 * RET_ARRAY known_spells   Indexed array with available known spells resrefs strings.
 */
DEFINE_DIMORPHIC_FUNCTION a7#pregen_spells_array
INT_VAR
  cleric = 0
  druid = 0
  cleric_level = 7
  druid_level = 7
  alignment = 0
RET
  known_spells
RET_ARRAY
  known_spells
BEGIN
  OUTER_SET known_spells = 0
  OUTER_SET valid = (cleric && cleric_level > 0) || (druid && druid_level > 0)
  ACTION_IF (valid) BEGIN
    // initializations
    OUTER_SET spl_type = 2
    OUTER_SET spl_ex_class  = cleric && NOT druid ? BIT30 : 0
    OUTER_SET spl_ex_class |= druid && NOT cleric ? BIT31 : 0
    OUTER_SET spl_ex_align  = (alignment & 0x30) == 10 ? BIT4 : 0
    OUTER_SET spl_ex_align |= (alignment & 0x30) == 20 ? BIT5 : 0
    OUTER_SET spl_ex_align |= (alignment & 0x30) == 30 ? BIT0 : 0
    OUTER_SET spl_ex_align |= (alignment & 0x03) == 1 ? BIT2 : 0
    OUTER_SET spl_ex_align |= (alignment & 0x03) == 2 ? BIT3 : 0
    OUTER_SET spl_ex_align |= (alignment & 0x03) == 3 ? BIT1 : 0

    // collecting priest spells by naming scheme
    OUTER_FOR (level = 1; level <= 7; ++level) BEGIN
      ACTION_IF (cleric && level <= cleric_level || druid && level <= druid_level) BEGIN
        OUTER_FOR (index = 1; index <= 50; ++index) BEGIN
          ACTION_IF (index < 10) BEGIN
            OUTER_SPRINT resref ~SPPR%level%0%index%~
          END ELSE BEGIN
            OUTER_SPRINT resref ~SPPR%level%%index%~
          END
          ACTION_IF (FILE_EXISTS_IN_GAME ~%resref%.SPL~) BEGIN
            OUTER_SET $spell_entries(~%resref%~) = 1
          END
        END
      END
    END

    // filter by HIDESPL.2DA entries
    SILENT
    COPY_EXISTING ~hidespl.2da~ ~override~
      READ_2DA_ENTRIES_NOW hidespl 1
      FOR (row = 3; row < hidespl; ++row) BEGIN
        SPRINT resref $hidespl(~%row%~ ~0~)
        TO_UPPER ~resref~
        SET hidden = $hidespl(~%row%~ ~1~) STR_EQ ~1~
        PATCH_IF (hidden && VARIABLE_IS_SET $spell_entries(~%resref%~)) BEGIN
          SET $spell_entries(~%resref%~) = 0
        END
      END
    BUT_ONLY
    VERBOSE

    ACTION_PHP_EACH spell_entries AS resref => enabled BEGIN
      ACTION_IF (enabled) BEGIN
        // filter by spell properties
        SILENT
        COPY_EXISTING ~%resref%.SPL~ ~override~
          READ_SHORT 0x1c type
          SET enabled = (type == spl_type)
          PATCH_IF (enabled) BEGIN
            READ_LONG 0x1e exclusion
            SET is_cleric = (exclusion & BIT30) == 0
            SET is_druid = (exclusion & BIT31) == 0
            SET mask = spl_ex_class | spl_ex_align
            SET enabled = (exclusion & mask) == 0
          END
          PATCH_IF (enabled) BEGIN
            READ_LONG 0x34 level
            SET enabled = (is_cleric && cleric && level <= cleric_level) || (is_druid && druid && level <= druid_level)
          END
        BUT_ONLY
        VERBOSE
      END

      // adding to known spell array
      ACTION_IF (enabled) BEGIN
        OUTER_SPRINT $known_spells(~%known_spells%~) ~%resref%~
        OUTER_SET known_spells += 1
      END
    END
  END
END


/**
 * Returns the CLAB tables associated with the specified class/kit combination.
 *
 * INT_VAR class          Numeric class value (CLASS.IDS).
 * INT_VAR kit            Numeric kit value (KIT.IDS).
 * RET clab_resref1       Resref of the CLAB 2DA table for the first base class or kit. Returns empty string if the CLAB
 *                        cannot be determined.
 * RET clab_resref2       Resref of the CLAB 2DA table for the second base class or kit (dual- and multiclasses only).
 *                        Returns empty string if the CLAB cannot be determined.
 * RET clab_resref3       Resref of the CLAB 2DA table for the third base class or kit (multiclasses only). Returns empty
 *                        string if the CLAB cannot be determined.
 * RET is_multiclass_kit  Returns whether the specified class/kit combination is a true multiclass kit.
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_clab
INT_VAR
  class = 0
  kit = 0
RET
  clab_resref1
  clab_resref2
  clab_resref3
  is_multiclass_kit
BEGIN
  OUTER_SPRINT clab_resref1 ~~
  OUTER_SPRINT clab_resref2 ~~
  OUTER_SPRINT clab_resref3 ~~
  OUTER_SET is_multiclass_kit = 0
  OUTER_SET success = (class > 0 && class < 22)
  
  ACTION_IF (success) BEGIN
    // map of hardcoded CLASS_label => CLAB_resref entries
    ACTION_DEFINE_ASSOCIATIVE_ARRAY class_tables BEGIN
      ~MAGE~      => ~clabma01~
      ~FIGHTER~   => ~clabfi01~
      ~CLERIC~    => ~clabpr01~
      ~THIEF~     => ~clabth01~
      ~BARD~      => ~clabba01~
      ~PALADIN~   => ~clabpa01~
      ~DRUID~     => ~clabdr01~
      ~RANGER~    => ~clabrn01~
      ~SORCERER~  => ~clabso01~
      ~MONK~      => ~clabmo01~
      ~SHAMAN~    => ~clabsh01~
    END

    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END
    OUTER_SET num_classes = (class3 > 0) ? 3 : (class2 > 0) ? 2 : 1

    LAF a7#get_kit_info INT_VAR kit RET kit_label kit_class END
    OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT kit_class_label ~class~ kit_class END
    OUTER_SET is_multiclass_kit = (kit != 0 && kit != TRUECLASS) && (num_classes > 1) && NOT VARIABLE_IS_SET $class_tables(~%kit_class_label%~)

    // getting kit CLAB resref
    OUTER_SPRINT kit_clab_resref ~~
    ACTION_IF (kit != 0 && kit != TRUECLASS) BEGIN
      SILENT
      COPY_EXISTING ~kitlist.2da~ ~override~
        READ_2DA_ENTRIES_NOW kitlist_table 1
        FOR (row = 4; row < kitlist_table; ++row) BEGIN
          SET kitids = $kitlist_table(~%row%~ ~9~)
          PATCH_IF (kitids == kit) BEGIN
            SPRINT resref $kitlist_table(~%row%~ ~5~)
            PATCH_IF (FILE_EXISTS_IN_GAME ~%resref%.2DA~) BEGIN
              SPRINT kit_clab_resref ~%resref%~
            END
            SET row = kitlist_table
          END
        END
      BUT_ONLY
      VERBOSE
    END

    OUTER_FOR (cls_idx = 1; cls_idx <= 3; ++cls_idx) BEGIN
      OUTER_SET cur_class = EVAL ~class%cls_idx%~
      ACTION_IF (cur_class > 0) BEGIN
        OUTER_PATCH ~~ BEGIN LOOKUP_IDS_SYMBOL_OF_INT cur_class_label ~class~ cur_class END
        ACTION_IF (cur_class == kit_class && NOT ~%kit_clab_resref%~ STR_EQ ~~) BEGIN
          OUTER_SPRINT EVAL ~clab_resref%cls_idx%~ ~%kit_clab_resref%~
        END ELSE ACTION_IF (VARIABLE_IS_SET $class_tables(~%cur_class_label%~)) BEGIN
          OUTER_SPRINT resref $class_tables(~%cur_class_label%~)
          OUTER_SPRINT EVAL ~clab_resref%cls_idx%~ ~%resref%~ // $class_tables(~%cur_class_label%~)
        END
      END
    END
  END
END


/**
 * Determines whether an innate spell is granted by the specified class or kit.
 *
 * INT_VAR class    Numeric class value (CLASS.IDS).
 * INT_VAR kit      Numeric kit value (KIT.IDS).
 * STR_VAR resref   Resref of the innate SPL resource to check.
 * RET found        Returns 1 if a reference was found, 0 otherwise.
 */
DEFINE_DIMORPHIC_FUNCTION a7#is_innate_defined
INT_VAR
  class = 0
  kit = 0
STR_VAR
  innate_resref = ~~
RET
  found
BEGIN
  OUTER_SET found = 0

  ACTION_IF (NOT ~%innate_resref%~ STR_EQ ~~) BEGIN
    LAF a7#get_clab INT_VAR class kit RET clab_resref1 clab_resref2 clab_resref3 is_multiclass_kit END
    LAF a7#get_base_classes INT_VAR class RET class1 class2 class3 END

    OUTER_FOR (cls_idx = 1; NOT found && cls_idx <= 3; ++cls_idx) BEGIN
      OUTER_SET cur_class = EVAL ~class%cls_idx%~
      ACTION_IF (cur_class > 0) BEGIN
        // getting CLAB table resref for the current class/kit aspect
        OUTER_SPRINT cur_clab_resref EVAL ~%clab_resref%cls_idx%%~
        ACTION_IF (NOT ~%cur_clab_resref%~ STR_EQ ~~) BEGIN
          SILENT
          COPY_EXISTING ~%cur_clab_resref%.2DA~ ~override~
            READ_2DA_ENTRIES_NOW ~%cur_clab_resref%_table~ 1
          BUT_ONLY
          VERBOSE

          OUTER_FOR (row = EVAL ~%cur_clab_resref%_table~ - 1; NOT found && row >= 3; --row) BEGIN
            OUTER_FOR (col = 1; NOT found && VARIABLE_IS_SET $EVAL ~%cur_clab_resref%_table~(~%row%~ ~%col%~); ++col) BEGIN
              OUTER_SPRINT entry $EVAL ~%cur_clab_resref%_table~(~%row%~ ~%col%~)
              ACTION_IF (~%entry%~ STRING_MATCHES_REGEXP ~^GA_.+~ == 0) BEGIN
                // scanning regular AP_* entries
                OUTER_PATCH_SAVE resref ~%entry%~ BEGIN REPLACE_TEXTUALLY ~^GA_~ ~~ END
                OUTER_SET found = ~%resref%~ STR_EQ ~%innate_resref%~
              END ELSE ACTION_IF (is_multiclass_kit && ~%entry%~ STRING_MATCHES_REGEXP ~^AP_QD_MC[DFMPRT][0-9][0-9]~ == 0) BEGIN
                // collecting multiclass kit meta spell resrefs
                OUTER_PATCH_SAVE resref ~%entry%~ BEGIN REPLACE_TEXTUALLY ~^AP_~ ~~ END
                ACTION_TO_UPPER ~resref~
                ACTION_IF (FILE_EXISTS_IN_GAME ~%resref%.SPL~) BEGIN
                  OUTER_SET $mc_spells(~%resref%~) = 1
                END
              END
            END
          END
        END
      END
    END

    ACTION_IF (is_multiclass_kit) BEGIN
      // collecting EFF resources with "grant innate ability" effects for this kit
      ACTION_PHP_EACH mc_spells AS spl_resref => _ BEGIN
        SILENT
        COPY_EXISTING ~%spl_resref%.SPL~ ~override~
          READ_LONG 0x64 ofs_abils
          READ_SHORT 0x68 num_abils
          READ_LONG 0x6a ofs_effects
          FOR (i = 0; i < num_abils; ++i) BEGIN
            SET ofs_abil = ofs_abils + i * 40
            READ_SHORT (ofs_abil + 0x1e) num_effects
            READ_SHORT (ofs_abil + 0x20) idx_effects
            FOR (j = 0; j < num_effects; ++j) BEGIN
              SET ofs_effect = ofs_effects + (idx_effects + j) * 48
              READ_SHORT ofs_effect opcode
              PATCH_IF (opcode == 177) BEGIN  // Use EFF file
                READ_LONG (ofs_effect + 0x04) p1
                READ_LONG (ofs_effect + 0x08) p2
                PATCH_IF (p1 == kit && p2 == 9) BEGIN   // kit_value=kit, target_type=kit
                  READ_ASCII (ofs_effect + 0x14) eff_resref (8) NULL
                  PATCH_IF (FILE_EXISTS_IN_GAME ~%eff_resref%.EFF~) BEGIN
                    TO_UPPER ~eff_resref~
                    SET $mc_eff(~%eff_resref%~) = 1
                  END
                END
              END
            END
          END
        BUT_ONLY IF_EXISTS
        VERBOSE
      END

      // scanning EFF resources for innate ability resrefs
      ACTION_PHP_EACH mc_eff AS eff_resref => _ BEGIN
        ACTION_IF (NOT found) BEGIN
          SILENT
          COPY_EXISTING ~%eff_resref%.EFF~ ~override~
            READ_LONG 0x10 opcode
            PATCH_IF (opcode == 171) BEGIN  // Give innate ability
              READ_ASCII 0x30 resref (8) NULL
              SET found = ~%resref%~ STR_EQ ~%innate_resref%~
            END
          BUT_ONLY IF_EXISTS
          VERBOSE
        END
      END
    END
  END
END


/**
 * Returns the creature animation value that matches the specified parameters.
 *
 * INT_VAR race     Numeric race value (RACE.IDS).
 * INT_VAR gender   Numeric gender value (GENDER.IDS).
 * INT_VAR class    Numeric class value (CLASS.IDS).
 * RET id           Numeric creature animation identifier.
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_animation_id
INT_VAR
  race = 0
  gender = 0
  class = 0
RET
  id
BEGIN
  // Base animation slot for creature animations
  OUTER_SET base_creature_animation = 0x6000

  // Races and their associated creature animations (RACE.IDS)
  ACTION_DEFINE_ASSOCIATIVE_ARRAY race_animation_table BEGIN
    // stores only the 0x000X hex digit of the animation id
    ~HUMAN~     => 0x0000
    ~ELF~       => 0x0001
    ~HALF_ELF~  => 0x0001
    ~DWARF~     => 0x0002
    ~HALFLING~  => 0x0003
    ~GNOME~     => 0x0004
    ~HALFORC~   => 0x0005
  END

  // Genders and their associated creature animations (GENDER.IDS)
  ACTION_DEFINE_ASSOCIATIVE_ARRAY gender_animation_table BEGIN
    // stores only the 0x00X0 hex digit of the animation id
    ~MALE~    => 0x0000
    ~FEMALE~  => 0x0010
  END

  // Classes and their associated creature animations (CLASS.IDS)
  ACTION_DEFINE_ASSOCIATIVE_ARRAY class_animation_table BEGIN
    // stores only the 0x0X00 hex digit of the animation id
    ~MAGE~                => 0x0200
    ~FIGHTER~             => 0x0100
    ~CLERIC~              => 0x0000
    ~THIEF~               => 0x0300
    ~BARD~                => 0x0300
    ~PALADIN~             => 0x0100
    ~FIGHTER_MAGE~        => 0x0100
    ~FIGHTER_CLERIC~      => 0x0100
    ~FIGHTER_THIEF~       => 0x0100
    ~FIGHTER_MAGE_THIEF~  => 0x0100
    ~DRUID~               => 0x0000
    ~RANGER~              => 0x0100
    ~MAGE_THIEF~          => 0x0300
    ~CLERIC_MAGE~         => 0x0000
    ~CLERIC_THIEF~        => 0x0000
    ~FIGHTER_DRUID~       => 0x0100
    ~FIGHTER_MAGE_CLERIC~ => 0x0100
    ~CLERIC_RANGER~       => 0x0100
    ~SORCERER~            => 0x0200
    ~MONK~                => 0x0500
    ~SHAMAN~              => 0x0000
  END

  OUTER_PATCH ~~ BEGIN
    SET id = base_creature_animation

    LOOKUP_IDS_SYMBOL_OF_INT race_label ~race~ race
    PATCH_IF (VARIABLE_IS_SET $race_animation_table(~%race_label%~)) BEGIN
      SET id |= $race_animation_table(~%race_label%~)
    END

    LOOKUP_IDS_SYMBOL_OF_INT gender_label ~gender~ gender
    PATCH_IF (VARIABLE_IS_SET $gender_animation_table(~%gender_label%~)) BEGIN
      SET id |= $gender_animation_table(~%gender_label%~)
    END

    LOOKUP_IDS_SYMBOL_OF_INT class_label ~class~ class
    PATCH_IF (VARIABLE_IS_SET $class_animation_table(~%class_label%~)) BEGIN
      SET id |= $class_animation_table(~%class_label%~)
    END
  END
END


/**
 * Returns a map of allowed racial enemies for the ranger class.
 *
 * RET num_races    Number of racial enemies stored in the "races" map.
 * RET_ARRAY races  Associative map of <race_id> => "<race_name>" entries that can be chosen as racial enemies for a ranger.
 */
DEFINE_DIMORPHIC_FUNCTION a7#get_haterace
RET
  num_races
RET_ARRAY
  races
BEGIN
  OUTER_SET num_races = 0
  SILENT
  COPY_EXISTING ~haterace.2da~ ~override~
    READ_2DA_ENTRIES_NOW haterace_table 1
    FOR (row = 3; row < haterace_table; ++row) BEGIN
      SET name_strref = $haterace_table(~%row%~ ~1~)
      GET_STRREF name_strref name
      SET id = $haterace_table(~%row%~ ~2~)
      SPRINT $races(~%id%~) ~%name%~
      SET num_races += 1
    END
  BUT_ONLY IF_EXISTS
  VERBOSE
END


/**
 * Returns kit id or kit label based on the given input.
 *
 * INT_VAR kit        Specify a numeric kit value to return the associated symbolic kit label. (Default: 0)
 * STR_VAR kit_label  Specify a symbolic kit label to return the associated kit identifier. Specifying a value for this
 *                    parameter overrides values in the "kit" parameter. (Default: "")
 * STR_VAR kitlist_table_name   Optional name of an pre-cached kitlist array. (Default: "")
 * RET kit            Returns a numeric kit value if the parameter "kit_label" contained a valid symbolic kit label.
 *                    Returns 0 otherwise.
 * RET kit_label      Returns a symbolic kit label if the parameter "kit" contained a valid kit value. Returns empty
 *                    string otherwise.
 */
DEFINE_DIMORPHIC_FUNCTION a7#convert_kit_label
INT_VAR
  kit = 0
STR_VAR
  kit_label = ~~
  kitlist_table_name = ~~
RET
  kit
  kit_label
BEGIN
  OUTER_SET is_label = NOT ~%kit_label%~ STR_EQ ~~
  OUTER_SET is_kit = (NOT is_label && kit != 0 && kit != "-1" && kit != TRUECLASS)
  ACTION_IF (is_label || is_kit) BEGIN
    ACTION_IF (~%kitlist_table_name%~ STR_EQ ~~ || NOT VARIABLE_IS_SET EVAL ~%kitlist_table_name%~) BEGIN
      OUTER_SPRINT kitlist_table_name ~kitlist_table~
      SILENT
      COPY_EXISTING ~kitlist.2da~ ~override~
        READ_2DA_ENTRIES_NOW ~%kitlist_table_name%~ 1
      BUT_ONLY
      VERBOSE
    END

    OUTER_FOR (row = 4; row < EVAL ~%kitlist_table_name%~; ++row) BEGIN
      ACTION_IF (is_kit) BEGIN
        // id => label
        OUTER_SPRINT cur_kit_value $EVAL ~%kitlist_table_name%~(~%row%~ ~9~)
        // LAF a7#get_validated_number STR_VAR number = EVAL ~%cur_kit_value%~ RET cur_kit = number END
        OUTER_SPRINT number ~%cur_kit_value%~ LAM a7#get_validated_number OUTER_SET cur_kit = number
        ACTION_IF (cur_kit == kit) BEGIN
          OUTER_SPRINT kit_label $EVAL ~%kitlist_table_name%~(~%row%~ ~1~)
          OUTER_SET row = EVAL ~%kitlist_table_name%~
        END
      END ELSE BEGIN
        // label => id
        OUTER_SPRINT cur_kit_label $EVAL ~%kitlist_table_name%~(~%row%~ ~1~)
        ACTION_IF (~%cur_kit_label%~ STR_EQ ~%kit_label%~) BEGIN
          OUTER_SPRINT cur_kit_value $EVAL ~%kitlist_table_name%~(~%row%~ ~9~)
          // LAF a7#get_validated_number STR_VAR number = EVAL ~%cur_kit_value%~ RET kit = number END
          OUTER_SPRINT number ~%cur_kit_value%~ LAM a7#get_validated_number OUTER_SET kit = number
        END
      END
    END
  END
END
